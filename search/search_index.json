{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"XTK - Expression Toolkit","text":"<p>Welcome to XTK (Expression Toolkit), a powerful symbolic expression toolkit for rule-based term rewriting in Python. XTK provides pattern matching, expression transformation, and symbolic computation capabilities with an interactive REPL featuring rich visualizations.</p>"},{"location":"#what-is-xtk","title":"What is XTK?","text":"<p>XTK is a Python package that enables symbolic computation through expression rewriting. It offers:</p> <ul> <li>Pattern Matching: Powerful and flexible pattern matching for symbolic expressions</li> <li>Rule-Based Transformations: Define and apply rewrite rules to transform expressions</li> <li>Expression Evaluation: Evaluate symbolic expressions with custom bindings</li> <li>Theorem Proving: Use tree search algorithms to prove mathematical theorems</li> <li>Interactive REPL: Explore and test expressions with rich visualizations</li> <li>Predefined Rules: Extensive collection of mathematical rules for algebra, calculus, trigonometry, and more</li> </ul>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#expression-rewriting-engine","title":"Expression Rewriting Engine","text":"<p>Transform symbolic expressions using pattern matching and rewrite rules. The system uses a simple yet powerful AST representation based on nested lists.</p>"},{"location":"#tree-search-algorithms","title":"Tree Search Algorithms","text":"<p>Explore expression spaces and prove theorems using various search strategies:</p> <ul> <li>Breadth-First Search (BFS)</li> <li>Depth-First Search (DFS)</li> <li>Iterative Deepening DFS (IDDFS)</li> <li>Best-First Search</li> <li>A* Search</li> <li>Monte Carlo Tree Search (MCTS)</li> </ul>"},{"location":"#rich-mathematical-library","title":"Rich Mathematical Library","text":"<p>Comes with predefined rules for:</p> <ul> <li>Symbolic differentiation</li> <li>Integration</li> <li>Algebraic manipulation</li> <li>Trigonometric identities</li> <li>Limits and calculus</li> <li>And much more!</li> </ul>"},{"location":"#interactive-development","title":"Interactive Development","text":"<p>Work with expressions interactively using the built-in REPL with syntax highlighting, tree visualization, and step-by-step transformation tracking.</p>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from xtk import rewriter\n\n# Define a rewrite rule: x + 0 =&gt; x\nrules = [\n    [['+', ['?', 'x'], 0], [':', 'x']]\n]\n\n# Create a rewriter function\nrewrite = rewriter(rules)\n\n# Apply the rule\nexpr = ['+', 'a', 0]\nresult = rewrite(expr)\nprint(result)  # Output: 'a'\n</code></pre>"},{"location":"#why-xtk","title":"Why XTK?","text":"<ul> <li>Simple and Powerful: Easy-to-learn AST representation that's also expressive</li> <li>Turing Complete: The rule system can express any computable function</li> <li>Extensible: Add your own rules and search strategies</li> <li>Well-Tested: Comprehensive test suite with high coverage</li> <li>Educational: Great for learning about symbolic computation and term rewriting</li> </ul>"},{"location":"#get-started","title":"Get Started","text":"<p>Ready to dive in? Check out our Quick Start Guide or install XTK now!</p>"},{"location":"#applications","title":"Applications","text":"<p>XTK is perfect for:</p> <ul> <li>Computer Algebra Systems: Build your own CAS with custom rules</li> <li>Theorem Proving: Automatically prove mathematical theorems</li> <li>Expression Optimization: Find simplified or equivalent forms</li> <li>Educational Tools: Teach symbolic manipulation and mathematics</li> <li>Research: Experiment with term rewriting and symbolic AI</li> </ul>"},{"location":"#community","title":"Community","text":"<ul> <li>GitHub: github.com/queelius/xtk</li> <li>Issues: Report bugs or request features</li> <li>PyPI: xpression-tk</li> </ul>"},{"location":"#license","title":"License","text":"<p>XTK is released under the MIT License.</p>"},{"location":"about/license/","title":"License","text":"<p>XTK is released under the MIT License.</p>"},{"location":"about/license/#mit-license","title":"MIT License","text":"<p>Copyright (c) 2025 Alex Towell</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"about/license/#what-this-means","title":"What This Means","text":"<p>The MIT License is one of the most permissive open source licenses. It allows you to:</p> <ul> <li>\u2705 Use XTK commercially</li> <li>\u2705 Modify the source code</li> <li>\u2705 Distribute your modifications</li> <li>\u2705 Sublicense the code</li> <li>\u2705 Use XTK in proprietary software</li> </ul> <p>The only requirements are:</p> <ul> <li>Include the license and copyright notice in your distributions</li> <li>Don't hold the authors liable</li> </ul>"},{"location":"about/license/#third-party-licenses","title":"Third-Party Licenses","text":"<p>XTK depends on the following third-party packages:</p>"},{"location":"about/license/#rich","title":"Rich","text":"<ul> <li>License: MIT License</li> <li>Copyright: Copyright (c) 2020 Will McGugan</li> <li>Purpose: Terminal formatting and visualization in the REPL</li> <li>Repository: https://github.com/Textualize/rich</li> </ul>"},{"location":"about/license/#contributing","title":"Contributing","text":"<p>By contributing to XTK, you agree that your contributions will be licensed under the same MIT License.</p> <p>See CONTRIBUTING.md for more details on contributing to XTK.</p>"},{"location":"about/license/#questions","title":"Questions?","text":"<p>If you have questions about the license, please open an issue on GitHub.</p>"},{"location":"api/core/","title":"Core API Reference","text":"<p>This document describes the core functions in XTK's rewriter module.</p>"},{"location":"api/core/#module-xtkrewriter","title":"Module: <code>xtk.rewriter</code>","text":"<p>The rewriter module provides the fundamental functions for pattern matching, instantiation, and evaluation.</p>"},{"location":"api/core/#match","title":"match()","text":"<pre><code>def match(pattern, expression, bindings) -&gt; Union[Dict, str]\n</code></pre> <p>Match a pattern against an expression and return updated bindings.</p> <p>Parameters:</p> <ul> <li><code>pattern</code> (ExprType): The pattern to match</li> <li><code>expression</code> (ExprType): The expression to match against</li> <li><code>bindings</code> (Dict): Dictionary of existing variable bindings</li> </ul> <p>Returns:</p> <ul> <li><code>Dict</code>: Updated bindings if match successful</li> <li><code>str</code>: <code>\"failed\"</code> if match unsuccessful</li> </ul> <p>Examples:</p> <pre><code>from xtk.rewriter import match\n\n# Simple match\npattern = ['+', ['?', 'x'], ['?', 'y']]\nexpr = ['+', 2, 3]\nresult = match(pattern, expr, {})\n# Returns: {'x': 2, 'y': 3}\n\n# Match with type constraint\npattern = ['*', ['?c', 'c'], ['?v', 'x']]\nexpr = ['*', 2, 'a']\nresult = match(pattern, expr, {})\n# Returns: {'c': 2, 'x': 'a'}\n\n# Failed match\npattern = ['+', ['?', 'x'], 0]\nexpr = ['+', 'a', 1]\nresult = match(pattern, expr, {})\n# Returns: \"failed\"\n</code></pre>"},{"location":"api/core/#instantiate","title":"instantiate()","text":"<pre><code>def instantiate(skeleton, bindings) -&gt; ExprType\n</code></pre> <p>Create a new expression from a skeleton using variable bindings.</p> <p>Parameters:</p> <ul> <li><code>skeleton</code> (ExprType): The skeleton template</li> <li><code>bindings</code> (Dict): Dictionary mapping variable names to values</li> </ul> <p>Returns:</p> <ul> <li><code>ExprType</code>: The instantiated expression</li> </ul> <p>Examples:</p> <pre><code>from xtk.rewriter import instantiate\n\n# Simple instantiation\nskeleton = ['+', [':', 'x'], [':', 'y']]\nbindings = {'x': 2, 'y': 3}\nresult = instantiate(skeleton, bindings)\n# Returns: ['+', 2, 3]\n\n# Nested instantiation\nskeleton = ['*', [':', 'a'], ['+', [':', 'b'], [':', 'c']]]\nbindings = {'a': 2, 'b': 3, 'c': 4}\nresult = instantiate(skeleton, bindings)\n# Returns: ['*', 2, ['+', 3, 4]]\n\n# Direct value\nskeleton = 42\nresult = instantiate(skeleton, {})\n# Returns: 42\n</code></pre>"},{"location":"api/core/#evaluate","title":"evaluate()","text":"<pre><code>def evaluate(expression, bindings) -&gt; Any\n</code></pre> <p>Evaluate an expression using the provided bindings.</p> <p>Parameters:</p> <ul> <li><code>expression</code> (ExprType): The expression to evaluate</li> <li><code>bindings</code> (Dict): Dictionary of operations and variable values</li> </ul> <p>Returns:</p> <ul> <li><code>Any</code>: The computed value</li> </ul> <p>Examples:</p> <pre><code>from xtk.rewriter import evaluate\n\n# Arithmetic evaluation\nexpr = ['+', 2, 3]\nbindings = {'+': lambda x, y: x + y}\nresult = evaluate(expr, bindings)\n# Returns: 5\n\n# With variables\nexpr = ['*', 'x', 'y']\nbindings = {\n    '*': lambda x, y: x * y,\n    'x': 4,\n    'y': 5\n}\nresult = evaluate(expr, bindings)\n# Returns: 20\n\n# Nested expression\nexpr = ['+', ['*', 2, 3], 4]\nbindings = {\n    '+': lambda x, y: x + y,\n    '*': lambda x, y: x * y\n}\nresult = evaluate(expr, bindings)\n# Returns: 10\n</code></pre>"},{"location":"api/core/#rewriter","title":"rewriter()","text":"<pre><code>def rewriter(rules) -&gt; Callable\n</code></pre> <p>Create a rewriting function from a list of rules.</p> <p>Parameters:</p> <ul> <li><code>rules</code> (List[RuleType]): List of <code>[pattern, skeleton]</code> pairs</li> </ul> <p>Returns:</p> <ul> <li><code>Callable</code>: A function that rewrites expressions</li> </ul> <p>Examples:</p> <pre><code>from xtk import rewriter\n\n# Create rewriter with simple rules\nrules = [\n    [['+', ['?', 'x'], 0], [':', 'x']],\n    [['*', ['?', 'x'], 1], [':', 'x']],\n]\nrewrite = rewriter(rules)\n\n# Use the rewriter\nexpr = ['+', 'a', 0]\nresult = rewrite(expr)\n# Returns: 'a'\n\nexpr = ['*', ['+', 'x', 0], 1]\nresult = rewrite(expr)\n# Returns: ['+', 'x', 0] (only rewrites at top level)\n</code></pre>"},{"location":"api/core/#utility-functions","title":"Utility Functions","text":""},{"location":"api/core/#car","title":"car()","text":"<pre><code>def car(lst: List) -&gt; Any\n</code></pre> <p>Return the first element of a list (head).</p> <p>Parameters:</p> <ul> <li><code>lst</code> (List): A non-empty list</li> </ul> <p>Returns:</p> <ul> <li><code>Any</code>: The first element</li> </ul> <p>Raises:</p> <ul> <li><code>TypeError</code>: If argument is not a list</li> <li><code>ValueError</code>: If list is empty</li> </ul> <p>Example:</p> <pre><code>from xtk.rewriter import car\n\nresult = car([1, 2, 3])\n# Returns: 1\n\nresult = car([['+', 'x', 'y'], 'z'])\n# Returns: ['+', 'x', 'y']\n</code></pre>"},{"location":"api/core/#cdr","title":"cdr()","text":"<pre><code>def cdr(lst: List) -&gt; List\n</code></pre> <p>Return all but the first element of a list (tail).</p> <p>Parameters:</p> <ul> <li><code>lst</code> (List): A list</li> </ul> <p>Returns:</p> <ul> <li><code>List</code>: All elements except the first</li> </ul> <p>Example:</p> <pre><code>from xtk.rewriter import cdr\n\nresult = cdr([1, 2, 3])\n# Returns: [2, 3]\n\nresult = cdr([1])\n# Returns: []\n</code></pre>"},{"location":"api/core/#cons","title":"cons()","text":"<pre><code>def cons(item: Any, lst: List) -&gt; List\n</code></pre> <p>Construct a new list by prepending an item.</p> <p>Parameters:</p> <ul> <li><code>item</code> (Any): The item to prepend</li> <li><code>lst</code> (List): The list to prepend to</li> </ul> <p>Returns:</p> <ul> <li><code>List</code>: A new list with item as first element</li> </ul> <p>Example:</p> <pre><code>from xtk.rewriter import cons\n\nresult = cons(1, [2, 3])\n# Returns: [1, 2, 3]\n\nresult = cons(['+', 'x'], ['y'])\n# Returns: [['+', 'x'], 'y']\n</code></pre>"},{"location":"api/core/#type-predicates","title":"Type Predicates","text":""},{"location":"api/core/#atom","title":"atom()","text":"<pre><code>def atom(exp: ExprType) -&gt; bool\n</code></pre> <p>Check if an expression is atomic (not compound).</p> <p>Parameters:</p> <ul> <li><code>exp</code> (ExprType): The expression to check</li> </ul> <p>Returns:</p> <ul> <li><code>bool</code>: True if atomic, False otherwise</li> </ul> <p>Example:</p> <pre><code>from xtk.rewriter import atom\n\natom(42)              # True\natom('x')             # True\natom(['+', 2, 3])     # False\n</code></pre>"},{"location":"api/core/#compound","title":"compound()","text":"<pre><code>def compound(exp: ExprType) -&gt; bool\n</code></pre> <p>Check if an expression is compound (a list).</p> <p>Parameters:</p> <ul> <li><code>exp</code> (ExprType): The expression to check</li> </ul> <p>Returns:</p> <ul> <li><code>bool</code>: True if compound, False otherwise</li> </ul> <p>Example:</p> <pre><code>from xtk.rewriter import compound\n\ncompound(['+', 2, 3])  # True\ncompound(42)           # False\ncompound('x')          # False\n</code></pre>"},{"location":"api/core/#constant","title":"constant()","text":"<pre><code>def constant(exp: ExprType) -&gt; bool\n</code></pre> <p>Check if an expression is a constant (number).</p> <p>Parameters:</p> <ul> <li><code>exp</code> (ExprType): The expression to check</li> </ul> <p>Returns:</p> <ul> <li><code>bool</code>: True if constant, False otherwise</li> </ul> <p>Example:</p> <pre><code>from xtk.rewriter import constant\n\nconstant(42)           # True\nconstant(3.14)         # True\nconstant('x')          # False\nconstant(['+', 2, 3])  # False\n</code></pre>"},{"location":"api/core/#variable","title":"variable()","text":"<pre><code>def variable(exp: ExprType) -&gt; bool\n</code></pre> <p>Check if an expression is a variable (string).</p> <p>Parameters:</p> <ul> <li><code>exp</code> (ExprType): The expression to check</li> </ul> <p>Returns:</p> <ul> <li><code>bool</code>: True if variable, False otherwise</li> </ul> <p>Example:</p> <pre><code>from xtk.rewriter import variable\n\nvariable('x')          # True\nvariable('foo')        # True\nvariable(42)           # False\nvariable(['+', 2, 3])  # False\n</code></pre>"},{"location":"api/core/#type-definitions","title":"Type Definitions","text":"<pre><code>from typing import Any, Dict, List, Union\n\nExprType = Union[int, float, str, List]\nDictType = Union[List[List], str]\nRuleType = List[List]\n</code></pre>"},{"location":"api/core/#exprtype","title":"ExprType","text":"<p>Represents any valid expression: - <code>int</code>: Integer constant - <code>float</code>: Floating-point constant - <code>str</code>: Variable or operator name - <code>List</code>: Compound expression</p>"},{"location":"api/core/#ruletype","title":"RuleType","text":"<p>A rule is a list containing: - <code>pattern</code>: First element (List) - <code>skeleton</code>: Second element (List or atomic value)</p>"},{"location":"api/core/#common-patterns","title":"Common Patterns","text":""},{"location":"api/core/#creating-a-simple-rewriter","title":"Creating a Simple Rewriter","text":"<pre><code>from xtk import rewriter\n\nrules = [\n    # Identity rules\n    [['+', ['?', 'x'], 0], [':', 'x']],\n    [['+', 0, ['?', 'x']], [':', 'x']],\n    [['*', ['?', 'x'], 1], [':', 'x']],\n    [['*', 1, ['?', 'x']], [':', 'x']],\n\n    # Zero rules\n    [['*', ['?', 'x'], 0], 0],\n    [['*', 0, ['?', 'x']], 0],\n]\n\nrewrite = rewriter(rules)\n\n# Use it\nexpr = ['+', ['*', 'x', 1], 0]\nresult = rewrite(expr)  # ['*', 'x', 1]\n</code></pre>"},{"location":"api/core/#testing-pattern-matches","title":"Testing Pattern Matches","text":"<pre><code>from xtk.rewriter import match\n\ndef test_pattern(pattern, expressions):\n    \"\"\"Test a pattern against multiple expressions.\"\"\"\n    for expr in expressions:\n        result = match(pattern, expr, {})\n        if result != \"failed\":\n            print(f\"{expr} matches: {result}\")\n        else:\n            print(f\"{expr} does not match\")\n\npattern = ['+', ['?c', 'x'], ['?c', 'y']]\ntest_pattern(pattern, [\n    ['+', 2, 3],      # matches\n    ['+', 'a', 'b'],  # does not match\n    ['+', 2, 'x'],    # does not match\n])\n</code></pre>"},{"location":"api/core/#error-handling","title":"Error Handling","text":""},{"location":"api/core/#matchfailure-exception","title":"MatchFailure Exception","text":"<p>Some internal functions may raise <code>MatchFailure</code>:</p> <pre><code>class MatchFailure(Exception):\n    \"\"\"Exception raised when pattern matching fails.\"\"\"\n    pass\n</code></pre>"},{"location":"api/core/#handling-match-failures","title":"Handling Match Failures","text":"<p>The public <code>match()</code> function returns <code>\"failed\"</code> instead of raising exceptions:</p> <pre><code>result = match(pattern, expr, {})\nif result == \"failed\":\n    print(\"Match failed\")\nelse:\n    print(f\"Bindings: {result}\")\n</code></pre>"},{"location":"api/core/#see-also","title":"See Also","text":"<ul> <li>Simplifier API - Recursive simplification</li> <li>Rule Loader API - Loading rules from files</li> <li>Search API - Tree search algorithms</li> </ul>"},{"location":"development/contributing/","title":"Contributing to XTK","text":"<p>Thank you for your interest in contributing to XTK! This guide will help you get started.</p>"},{"location":"development/contributing/#ways-to-contribute","title":"Ways to Contribute","text":"<p>There are many ways to contribute to XTK:</p> <ul> <li>Bug Reports: Report issues you encounter</li> <li>Feature Requests: Suggest new features or improvements</li> <li>Documentation: Improve or add to the documentation</li> <li>Code: Fix bugs or implement new features</li> <li>Examples: Add examples or tutorials</li> <li>Rules: Contribute new mathematical rule sets</li> </ul>"},{"location":"development/contributing/#getting-started","title":"Getting Started","text":""},{"location":"development/contributing/#1-fork-and-clone","title":"1. Fork and Clone","text":"<p>Fork the repository on GitHub and clone it locally:</p> <pre><code>git clone https://github.com/YOUR-USERNAME/xtk.git\ncd xtk\n</code></pre>"},{"location":"development/contributing/#2-set-up-development-environment","title":"2. Set Up Development Environment","text":"<p>Create a virtual environment and install dependencies:</p> <pre><code>python -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\npip install -e \".[dev]\"\n</code></pre> <p>This installs XTK in editable mode with development dependencies.</p>"},{"location":"development/contributing/#3-create-a-branch","title":"3. Create a Branch","text":"<p>Create a new branch for your work:</p> <pre><code>git checkout -b feature/your-feature-name\n# or\ngit checkout -b fix/your-bug-fix\n</code></pre>"},{"location":"development/contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"development/contributing/#running-tests","title":"Running Tests","text":"<p>Run the full test suite:</p> <pre><code>python -m unittest discover -s tests -p \"*.py\"\n</code></pre> <p>Run a specific test file:</p> <pre><code>python -m unittest tests.test_rewriter\n</code></pre>"},{"location":"development/contributing/#test-coverage","title":"Test Coverage","text":"<p>Check test coverage:</p> <pre><code>pytest --cov=xtk tests/\n</code></pre> <p>Aim for high coverage (90%+) for new code.</p>"},{"location":"development/contributing/#code-style","title":"Code Style","text":"<p>XTK follows PEP 8 style guidelines. Format your code with black:</p> <pre><code>black src/xtk tests\n</code></pre> <p>Check with flake8:</p> <pre><code>flake8 src/xtk tests\n</code></pre>"},{"location":"development/contributing/#type-checking","title":"Type Checking","text":"<p>Run mypy for type checking:</p> <pre><code>mypy src/xtk\n</code></pre>"},{"location":"development/contributing/#making-changes","title":"Making Changes","text":""},{"location":"development/contributing/#code-changes","title":"Code Changes","text":"<ol> <li>Keep changes focused: One feature or fix per PR</li> <li>Write tests: Add tests for new functionality</li> <li>Update docs: Update documentation if needed</li> <li>Follow style: Use black, follow PEP 8</li> <li>Type hints: Add type annotations</li> </ol>"},{"location":"development/contributing/#example-adding-a-new-function","title":"Example: Adding a New Function","text":"<pre><code>def new_function(expr: ExprType, param: int) -&gt; ExprType:\n    \"\"\"\n    Brief description of what the function does.\n\n    Args:\n        expr: Description of expr parameter\n        param: Description of param parameter\n\n    Returns:\n        Description of return value\n\n    Example:\n        &gt;&gt;&gt; new_function(['+', 'x', 3], 2)\n        ['+', 'x', 5]\n    \"\"\"\n    # Implementation here\n    pass\n</code></pre>"},{"location":"development/contributing/#adding-rules","title":"Adding Rules","text":"<p>To contribute new rule sets:</p> <ol> <li>Create a new file in <code>src/xtk/rules/</code></li> <li>Follow the existing rule format</li> <li>Add documentation comments</li> <li>Add tests in <code>tests/</code></li> </ol> <p>Example:</p> <pre><code>\"\"\"\nHyperbolic trig rules for XTK.\n\nThis module provides rewrite rules for hyperbolic trigonometric functions.\n\"\"\"\n\nrules = [\n    # sinh(x) = (e^x - e^(-x))/2\n    [['sinh', ['?', 'x']],\n     ['/', ['-', ['^', 'e', [':', 'x']],\n                 ['^', 'e', ['-', 0, [':', 'x']]]], 2]],\n\n    # Add more rules...\n]\n</code></pre>"},{"location":"development/contributing/#documentation-changes","title":"Documentation Changes","text":"<p>Documentation is in markdown format in the <code>docs/</code> directory. To contribute:</p> <ol> <li>Edit or create <code>.md</code> files</li> <li>Follow existing structure</li> <li>Use clear, concise language</li> <li>Include code examples</li> <li>Build locally to verify</li> </ol> <p>Build docs with MkDocs:</p> <pre><code>mkdocs serve\n</code></pre> <p>Then visit http://127.0.0.1:8000</p>"},{"location":"development/contributing/#pull-request-process","title":"Pull Request Process","text":""},{"location":"development/contributing/#1-before-submitting","title":"1. Before Submitting","text":"<ul> <li>[ ] Tests pass locally</li> <li>[ ] Code is formatted (black)</li> <li>[ ] No linting errors (flake8)</li> <li>[ ] Type checking passes (mypy)</li> <li>[ ] Documentation is updated</li> <li>[ ] Commit messages are clear</li> </ul>"},{"location":"development/contributing/#2-submit-pr","title":"2. Submit PR","text":"<p>Push your branch and create a pull request:</p> <pre><code>git push origin feature/your-feature-name\n</code></pre> <p>Then open a PR on GitHub.</p>"},{"location":"development/contributing/#3-pr-description","title":"3. PR Description","text":"<p>Write a clear description:</p> <pre><code>## Description\nBrief description of changes\n\n## Motivation\nWhy is this change needed?\n\n## Changes\n- List of specific changes\n- Another change\n\n## Testing\nHow was this tested?\n\n## Checklist\n- [ ] Tests added/updated\n- [ ] Documentation updated\n- [ ] Code formatted\n- [ ] Type hints added\n</code></pre>"},{"location":"development/contributing/#4-review-process","title":"4. Review Process","text":"<ul> <li>Maintainers will review your PR</li> <li>Address any feedback</li> <li>Update your branch if needed</li> <li>Once approved, it will be merged</li> </ul>"},{"location":"development/contributing/#coding-standards","title":"Coding Standards","text":""},{"location":"development/contributing/#python-style","title":"Python Style","text":"<ul> <li>Follow PEP 8</li> <li>Use type hints</li> <li>Write docstrings for all public functions</li> <li>Keep functions focused and small</li> <li>Prefer functional style where appropriate</li> </ul>"},{"location":"development/contributing/#testing-standards","title":"Testing Standards","text":"<ul> <li>Write unit tests for all new code</li> <li>Use descriptive test names</li> <li>Test edge cases</li> <li>Aim for high coverage</li> </ul> <p>Example test:</p> <pre><code>class TestNewFunction(unittest.TestCase):\n    def test_basic_case(self):\n        \"\"\"Test basic functionality.\"\"\"\n        result = new_function(['+', 'x', 3], 2)\n        self.assertEqual(result, ['+', 'x', 5])\n\n    def test_edge_case(self):\n        \"\"\"Test edge case with zero.\"\"\"\n        result = new_function(['+', 'x', 0], 0)\n        self.assertEqual(result, ['+', 'x', 0])\n</code></pre>"},{"location":"development/contributing/#documentation-standards","title":"Documentation Standards","text":"<ul> <li>Write clear, concise documentation</li> <li>Include examples in docstrings</li> <li>Update user guides for new features</li> <li>Use proper markdown formatting</li> </ul>"},{"location":"development/contributing/#bug-reports","title":"Bug Reports","text":"<p>When reporting bugs, include:</p> <ol> <li>Description: What's the problem?</li> <li>Reproduction: Steps to reproduce</li> <li>Expected: What should happen?</li> <li>Actual: What actually happens?</li> <li>Environment: Python version, OS, XTK version</li> </ol> <p>Example:</p> <pre><code>**Bug Description**\nPattern matching fails for nested lists\n\n**To Reproduce**\n```python\npattern = ['+', ['?', 'x'], ['?', 'y']]\nexpr = ['+', ['+', 'a', 'b'], 'c']\nresult = match(pattern, expr, {})\n# Returns \"failed\" but should succeed\n</code></pre> <p>Expected Behavior Should return {'x': ['+', 'a', 'b'], 'y': 'c'}</p> <p>Actual Behavior Returns \"failed\"</p> <p>Environment - Python 3.9 - XTK 0.2.0 - Ubuntu 20.04 ```</p>"},{"location":"development/contributing/#feature-requests","title":"Feature Requests","text":"<p>When requesting features:</p> <ol> <li>Use case: Why is this needed?</li> <li>Description: What should it do?</li> <li>Example: Show example usage</li> <li>Alternatives: What are workarounds?</li> </ol>"},{"location":"development/contributing/#community-guidelines","title":"Community Guidelines","text":""},{"location":"development/contributing/#code-of-conduct","title":"Code of Conduct","text":"<ul> <li>Be respectful and inclusive</li> <li>Welcome newcomers</li> <li>Give constructive feedback</li> <li>Focus on the code, not the person</li> </ul>"},{"location":"development/contributing/#communication","title":"Communication","text":"<ul> <li>Issues: For bugs and features</li> <li>Discussions: For questions and ideas</li> <li>Pull Requests: For code contributions</li> </ul>"},{"location":"development/contributing/#recognition","title":"Recognition","text":"<p>Contributors will be:</p> <ul> <li>Listed in CONTRIBUTORS.md</li> <li>Mentioned in release notes</li> <li>Credited in documentation (for major contributions)</li> </ul>"},{"location":"development/contributing/#questions","title":"Questions?","text":"<p>If you have questions:</p> <ol> <li>Check the documentation</li> <li>Search existing issues</li> <li>Open a new issue with your question</li> </ol>"},{"location":"development/contributing/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the MIT License.</p> <p>Thank you for contributing to XTK!</p>"},{"location":"examples/differentiation/","title":"Symbolic Differentiation","text":"<p>This example demonstrates how to use XTK for symbolic differentiation, one of its most powerful applications.</p>"},{"location":"examples/differentiation/#overview","title":"Overview","text":"<p>Symbolic differentiation computes derivatives of expressions symbolically (not numerically). XTK implements differentiation through rewrite rules based on calculus rules.</p>"},{"location":"examples/differentiation/#basic-differentiation","title":"Basic Differentiation","text":""},{"location":"examples/differentiation/#derivative-of-a-constant","title":"Derivative of a Constant","text":"<p>The derivative of a constant is always zero: \\(\\frac{d}{dx}(c) = 0\\)</p> <pre><code>from xtk import rewriter\nfrom xtk.rule_loader import load_rules\n\n# Load derivative rules\nrules = load_rules('src/xtk/rules/deriv_rules.py')\ndiff = rewriter(rules)\n\n# Differentiate a constant\nexpr = ['dd', 5, 'x']  # d/dx(5)\nresult = diff(expr)\nprint(result)  # 0\n</code></pre>"},{"location":"examples/differentiation/#derivative-of-a-variable","title":"Derivative of a Variable","text":"<p>The derivative of a variable with respect to itself is 1: \\(\\frac{d}{dx}(x) = 1\\)</p> <pre><code>expr = ['dd', 'x', 'x']  # d/dx(x)\nresult = diff(expr)\nprint(result)  # 1\n</code></pre>"},{"location":"examples/differentiation/#power-rule","title":"Power Rule","text":"<p>The power rule: \\(\\frac{d}{dx}(x^n) = n \\cdot x^{n-1}\\)</p> <pre><code># d/dx(x^2) = 2*x^1 = 2*x\nexpr = ['dd', ['^', 'x', 2], 'x']\nresult = diff(expr)\nprint(result)  # ['*', 2, ['^', 'x', 1]]\n\n# Simplify further\nfrom xtk.simplifier import simplifier\nsimplify = simplifier(rules)\nresult = simplify(result)\nprint(result)  # ['*', 2, 'x']\n\n# d/dx(x^3) = 3*x^2\nexpr = ['dd', ['^', 'x', 3], 'x']\nresult = diff(expr)\nprint(result)  # ['*', 3, ['^', 'x', 2]]\n</code></pre>"},{"location":"examples/differentiation/#sum-rule","title":"Sum Rule","text":"<p>The sum rule: \\(\\frac{d}{dx}(f + g) = \\frac{df}{dx} + \\frac{dg}{dx}\\)</p> <pre><code># d/dx(x^2 + x^3)\nexpr = ['dd', ['+', ['^', 'x', 2], ['^', 'x', 3]], 'x']\nresult = simplify(expr)\nprint(result)\n# ['+', ['*', 2, 'x'], ['*', 3, ['^', 'x', 2]]]\n</code></pre>"},{"location":"examples/differentiation/#product-rule","title":"Product Rule","text":"<p>The product rule: \\(\\frac{d}{dx}(f \\cdot g) = \\frac{df}{dx} \\cdot g + f \\cdot \\frac{dg}{dx}\\)</p> <pre><code># d/dx(x * x) = 1*x + x*1 = 2x\nexpr = ['dd', ['*', 'x', 'x'], 'x']\nresult = simplify(expr)\nprint(result)  # ['*', 2, 'x'] or equivalent\n</code></pre>"},{"location":"examples/differentiation/#example-derivative-of-x2-cdot-x3","title":"Example: Derivative of \\(x^2 \\cdot x^3\\)","text":"<pre><code>expr = ['dd', ['*', ['^', 'x', 2], ['^', 'x', 3]], 'x']\nresult = simplify(expr)\n# Result: ['*', 5, ['^', 'x', 4]]\n# (This uses both product rule and simplification)\n</code></pre>"},{"location":"examples/differentiation/#chain-rule","title":"Chain Rule","text":"<p>The chain rule: \\(\\frac{d}{dx}(f(g(x))) = f'(g(x)) \\cdot g'(x)\\)</p> <pre><code># d/dx((x^2)^3) = 3*(x^2)^2 * 2*x\nexpr = ['dd', ['^', ['^', 'x', 2], 3], 'x']\nresult = simplify(expr)\nprint(result)\n# Simplified: ['*', 6, ['^', 'x', 5]]\n</code></pre>"},{"location":"examples/differentiation/#trigonometric-functions","title":"Trigonometric Functions","text":""},{"location":"examples/differentiation/#derivative-of-sinx","title":"Derivative of sin(x)","text":"<p>\\(\\frac{d}{dx}(\\sin(x)) = \\cos(x)\\)</p> <pre><code># Load trigonometric rules too\ntrig_rules = load_rules('src/xtk/rules/trig_rules.py')\nall_rules = rules + trig_rules\ndiff_trig = simplifier(all_rules)\n\nexpr = ['dd', ['sin', 'x'], 'x']\nresult = diff_trig(expr)\nprint(result)  # ['cos', 'x']\n</code></pre>"},{"location":"examples/differentiation/#derivative-of-cosx","title":"Derivative of cos(x)","text":"<p>\\(\\frac{d}{dx}(\\cos(x)) = -\\sin(x)\\)</p> <pre><code>expr = ['dd', ['cos', 'x'], 'x']\nresult = diff_trig(expr)\nprint(result)  # ['-', 0, ['sin', 'x']] or equivalent\n</code></pre>"},{"location":"examples/differentiation/#complete-example-polynomial-derivative","title":"Complete Example: Polynomial Derivative","text":"<p>Let's differentiate a complete polynomial: \\(f(x) = 3x^3 + 2x^2 - 5x + 7\\)</p> <pre><code>from xtk import rewriter\nfrom xtk.rule_loader import load_rules\nfrom xtk.simplifier import simplifier\n\n# Setup\nrules = load_rules('src/xtk/rules/deriv_rules.py')\nalgebra_rules = load_rules('src/xtk/rules/algebra_rules.py')\nall_rules = rules + algebra_rules\nsimplify = simplifier(all_rules)\n\n# Define the polynomial\npolynomial = ['+',\n    ['+',\n        ['*', 3, ['^', 'x', 3]],\n        ['*', 2, ['^', 'x', 2]]\n    ],\n    ['+',\n        ['*', -5, 'x'],\n        7\n    ]\n]\n\n# Differentiate\nexpr = ['dd', polynomial, 'x']\nresult = simplify(expr)\n\nprint(\"Derivative:\")\nprint(result)\n# Expected: 9x^2 + 4x - 5\n# Output: ['+', ['+', ['*', 9, ['^', 'x', 2]], ['*', 4, 'x']], -5]\n</code></pre>"},{"location":"examples/differentiation/#using-the-repl-for-differentiation","title":"Using the REPL for Differentiation","text":"<p>The interactive REPL makes differentiation even easier:</p> <pre><code>$ python -m xtk.cli\nxtk&gt; /rules load src/xtk/rules/deriv_rules.py\nLoaded 15 derivative rules\n\nxtk&gt; (dd (^ x 2) x)\nExpression: ['dd', ['^', 'x', 2], 'x']\n\nxtk&gt; /simplify\nSimplified: ['*', 2, 'x']\n\nxtk&gt; /tree\n*\n\u251c\u2500\u2500 2\n\u2514\u2500\u2500 x\n</code></pre>"},{"location":"examples/differentiation/#advanced-multiple-variables","title":"Advanced: Multiple Variables","text":"<p>XTK supports partial derivatives with multiple variables:</p> <pre><code># \u2202/\u2202x(x*y) = y\nexpr = ['dd', ['*', 'x', 'y'], 'x']\nresult = diff(expr)\nprint(result)  # 'y'\n\n# \u2202/\u2202y(x*y) = x\nexpr = ['dd', ['*', 'x', 'y'], 'y']\nresult = diff(expr)\nprint(result)  # 'x'\n\n# \u2202/\u2202x(x^2 + y^2) = 2x\nexpr = ['dd', ['+', ['^', 'x', 2], ['^', 'y', 2]], 'x']\nresult = simplify(expr)\nprint(result)  # ['*', 2, 'x']\n</code></pre>"},{"location":"examples/differentiation/#building-custom-differentiation-rules","title":"Building Custom Differentiation Rules","text":"<p>You can extend the differentiation rules:</p> <pre><code>custom_rules = [\n    # d/dx(e^x) = e^x\n    [['dd', ['^', 'e', ['?v', 'x']], ['?v', 'x']],\n     ['^', 'e', [':', 'x']]],\n\n    # d/dx(ln(x)) = 1/x\n    [['dd', ['ln', ['?v', 'x']], ['?v', 'x']],\n     ['/', 1, [':', 'x']]],\n\n    # d/dx(tan(x)) = sec^2(x)\n    [['dd', ['tan', ['?v', 'x']], ['?v', 'x']],\n     ['^', ['sec', [':', 'x']], 2]],\n]\n\n# Combine with existing rules\nextended_rules = rules + custom_rules\ndiff_extended = simplifier(extended_rules)\n\n# Use extended differentiation\nexpr = ['dd', ['^', 'e', 'x'], 'x']\nresult = diff_extended(expr)\nprint(result)  # ['^', 'e', 'x']\n</code></pre>"},{"location":"examples/differentiation/#practical-applications","title":"Practical Applications","text":""},{"location":"examples/differentiation/#1-finding-critical-points","title":"1. Finding Critical Points","text":"<pre><code>def find_critical_points_symbolic(func, var):\n    \"\"\"Return the derivative of func with respect to var.\"\"\"\n    deriv_expr = ['dd', func, var]\n    return simplify(deriv_expr)\n\n# f(x) = x^3 - 3x^2 + 2\nfunc = ['+', ['-', ['^', 'x', 3], ['*', 3, ['^', 'x', 2]]], 2]\ncritical = find_critical_points_symbolic(func, 'x')\nprint(\"f'(x) =\", critical)\n# Output: 3x^2 - 6x\n# Critical points where this equals 0: x=0, x=2\n</code></pre>"},{"location":"examples/differentiation/#2-taylor-series-first-term","title":"2. Taylor Series (First Term)","text":"<pre><code>def taylor_first_order(func, var, point):\n    \"\"\"First-order Taylor approximation: f(a) + f'(a)(x-a)\"\"\"\n    # This is conceptual - you'd need evaluation rules\n    deriv = ['dd', func, var]\n    return ['+',\n        ['eval', func, {var: point}],\n        ['*', ['eval', deriv, {var: point}], ['-', var, point]]\n    ]\n</code></pre>"},{"location":"examples/differentiation/#3-gradient-descent-step","title":"3. Gradient Descent Step","text":"<pre><code>def gradient_step(func, var):\n    \"\"\"Compute gradient descent update direction.\"\"\"\n    return ['dd', func, var]\n\n# For f(x) = x^2, gradient is 2x\n# Update: x_new = x - \u03b1 * 2x\n</code></pre>"},{"location":"examples/differentiation/#error-handling","title":"Error Handling","text":"<pre><code># If derivative rules aren't loaded\ntry:\n    expr = ['dd', ['^', 'x', 2], 'x']\n    result = diff(expr)\n    if result == expr:  # No change means rule didn't apply\n        print(\"Warning: Derivative rules may not be loaded\")\nexcept Exception as e:\n    print(f\"Error: {e}\")\n</code></pre>"},{"location":"examples/differentiation/#performance-tips","title":"Performance Tips","text":"<ol> <li>Load rules once: Don't reload rules for each differentiation</li> <li>Simplify after: Apply simplification after differentiation</li> <li>Use specific rules: More specific rules match faster</li> <li>Cache results: Store computed derivatives for reuse</li> </ol>"},{"location":"examples/differentiation/#common-issues","title":"Common Issues","text":""},{"location":"examples/differentiation/#issue-derivative-not-simplifying","title":"Issue: Derivative Not Simplifying","text":"<p>Problem: <code>['*', 1, 'x']</code> instead of <code>'x'</code></p> <p>Solution: Load algebra rules for simplification:</p> <pre><code>algebra_rules = load_rules('src/xtk/rules/algebra_rules.py')\nall_rules = deriv_rules + algebra_rules\nsimplify = simplifier(all_rules)\n</code></pre>"},{"location":"examples/differentiation/#issue-chain-rule-not-applying","title":"Issue: Chain Rule Not Applying","text":"<p>Problem: Nested functions not differentiating correctly</p> <p>Solution: Ensure you have chain rule in your rules and use <code>simplifier()</code> instead of <code>rewriter()</code>:</p> <pre><code>from xtk.simplifier import simplifier\nsimplify = simplifier(rules)  # Applies rules recursively\n</code></pre>"},{"location":"examples/differentiation/#next-steps","title":"Next Steps","text":"<ul> <li>Try Integration examples</li> <li>Learn about Algebraic Simplification</li> <li>Explore Trigonometric Identities</li> <li>Read about Custom Rules</li> </ul>"},{"location":"examples/differentiation/#references","title":"References","text":"<ul> <li>Core API Documentation</li> <li>Simplifier API</li> <li>Pattern Matching Guide</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>XTK can be installed using pip or from source.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8 or higher</li> <li>pip (Python package installer)</li> </ul>"},{"location":"getting-started/installation/#install-from-pypi","title":"Install from PyPI","text":"<p>The easiest way to install XTK is from PyPI:</p> <pre><code>pip install xpression-tk\n</code></pre> <p>Note: The package is published as <code>xpression-tk</code> but imported as <code>xtk</code>.</p>"},{"location":"getting-started/installation/#install-from-source","title":"Install from Source","text":"<p>To get the latest development version:</p> <pre><code>git clone https://github.com/queelius/xtk.git\ncd xtk\npip install -e .\n</code></pre> <p>The <code>-e</code> flag installs the package in editable mode, which is useful for development.</p>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Verify that XTK is installed correctly:</p> <pre><code>import xtk\nprint(xtk.__version__)\n</code></pre> <p>Or launch the interactive REPL:</p> <pre><code>python -m xtk.cli\n</code></pre> <p>You should see the XTK prompt:</p> <pre><code>xtk&gt;\n</code></pre>"},{"location":"getting-started/installation/#optional-dependencies","title":"Optional Dependencies","text":""},{"location":"getting-started/installation/#development-tools","title":"Development Tools","text":"<p>If you plan to contribute to XTK or run tests:</p> <pre><code>pip install xpression-tk[dev]\n</code></pre> <p>This installs:</p> <ul> <li>pytest - Testing framework</li> <li>pytest-cov - Code coverage</li> <li>black - Code formatter</li> <li>flake8 - Linter</li> <li>mypy - Type checker</li> <li>isort - Import sorter</li> </ul>"},{"location":"getting-started/installation/#documentation-tools","title":"Documentation Tools","text":"<p>To build the documentation locally:</p> <pre><code>pip install mkdocs mkdocs-material pymdown-extensions\n</code></pre>"},{"location":"getting-started/installation/#system-requirements","title":"System Requirements","text":"<p>XTK is a pure Python package and works on:</p> <ul> <li>Linux</li> <li>macOS</li> <li>Windows</li> </ul> <p>Minimum system requirements:</p> <ul> <li>100MB disk space</li> <li>256MB RAM (more for complex computations)</li> </ul>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#import-error","title":"Import Error","text":"<p>If you get <code>ModuleNotFoundError: No module named 'xtk'</code>:</p> <ol> <li>Ensure you installed <code>xpression-tk</code> (not <code>xtk</code>)</li> <li>Check your Python environment: <code>pip list | grep xpression</code></li> <li>Verify Python version: <code>python --version</code> (must be 3.8+)</li> </ol>"},{"location":"getting-started/installation/#permission-errors","title":"Permission Errors","text":"<p>On Unix systems, you may need to use <code>pip3</code> instead of <code>pip</code>, or install with <code>--user</code>:</p> <pre><code>pip3 install --user xpression-tk\n</code></pre> <p>Or use a virtual environment (recommended):</p> <pre><code>python3 -m venv xtk-env\nsource xtk-env/bin/activate  # On Windows: xtk-env\\Scripts\\activate\npip install xpression-tk\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Now that XTK is installed, check out the Quick Start Guide to begin using it!</p>"},{"location":"getting-started/quickstart/","title":"Quick Start Guide","text":"<p>This guide will get you started with XTK in just a few minutes.</p>"},{"location":"getting-started/quickstart/#your-first-expression-rewrite","title":"Your First Expression Rewrite","text":"<p>Let's start with a simple example that demonstrates the core concept of XTK:</p> <pre><code>from xtk import rewriter\n\n# Define a simple rewrite rule: x + 0 =&gt; x\nrules = [\n    [['+', ['?', 'x'], 0], [':', 'x']]\n]\n\n# Create a rewriter function\nrewrite = rewriter(rules)\n\n# Apply the rule\nexpr = ['+', 'a', 0]\nresult = rewrite(expr)\nprint(f\"Rewritten: {result}\")  # Output: 'a'\n</code></pre>"},{"location":"getting-started/quickstart/#understanding-the-example","title":"Understanding the Example","text":"<p>Let's break down what's happening:</p> <ol> <li>Rules: Rules are pairs of <code>[pattern, skeleton]</code></li> <li>Pattern: <code>['+', ['?', 'x'], 0]</code> matches any expression of the form \"something + 0\"</li> <li> <p>Skeleton: <code>[':', 'x']</code> means \"replace with whatever matched x\"</p> </li> <li> <p>Pattern Variables:</p> </li> <li><code>['?', 'x']</code> matches any expression and binds it to variable <code>x</code></li> <li> <p><code>[':', 'x']</code> in the skeleton substitutes the value bound to <code>x</code></p> </li> <li> <p>Expression: <code>['+', 'a', 0]</code> is the AST representation of <code>a + 0</code></p> </li> </ol>"},{"location":"getting-started/quickstart/#using-the-interactive-repl","title":"Using the Interactive REPL","text":"<p>The fastest way to explore XTK is through the interactive REPL:</p> <pre><code>python -m xtk.cli\n</code></pre> <p>Try these commands:</p> <pre><code>xtk&gt; (+ 2 3)\nExpression: ['+', 2, 3]\n\nxtk&gt; /rewrite\nRewritten: 5\n\nxtk&gt; /help\n[Shows available commands]\n</code></pre>"},{"location":"getting-started/quickstart/#repl-commands","title":"REPL Commands","text":"<ul> <li><code>/rewrite</code> or <code>/rw</code> - Rewrite the current expression</li> <li><code>/tree</code> - Display expression as a tree</li> <li><code>/rules load &lt;file&gt;</code> - Load rules from a file</li> <li><code>/eval</code> - Evaluate the expression</li> <li><code>/help</code> - Show all commands</li> </ul>"},{"location":"getting-started/quickstart/#pattern-matching-examples","title":"Pattern Matching Examples","text":""},{"location":"getting-started/quickstart/#match-any-expression","title":"Match Any Expression","text":"<pre><code>from xtk.rewriter import match\n\npattern = ['?', 'x']\nexpr = ['+', 2, 3]\nresult = match(pattern, expr, {})\nprint(result)  # {'x': ['+', 2, 3]}\n</code></pre>"},{"location":"getting-started/quickstart/#match-constants","title":"Match Constants","text":"<pre><code>pattern = ['?c', 'c']\nexpr = 42\nresult = match(pattern, expr, {})\nprint(result)  # {'c': 42}\n</code></pre>"},{"location":"getting-started/quickstart/#match-variables","title":"Match Variables","text":"<pre><code>pattern = ['?v', 'x']\nexpr = 'y'\nresult = match(pattern, expr, {})\nprint(result)  # {'x': 'y'}\n</code></pre>"},{"location":"getting-started/quickstart/#common-rewrite-rules","title":"Common Rewrite Rules","text":""},{"location":"getting-started/quickstart/#identity-rules","title":"Identity Rules","text":"<pre><code># x + 0 = x\n[['+', ['?', 'x'], 0], [':', 'x']]\n\n# x * 1 = x\n[['*', ['?', 'x'], 1], [':', 'x']]\n\n# x * 0 = 0\n[['*', ['?', 'x'], 0], 0]\n</code></pre>"},{"location":"getting-started/quickstart/#commutative-rules","title":"Commutative Rules","text":"<pre><code># x + y = y + x\n[['+', ['?', 'x'], ['?', 'y']], ['+', [':', 'y'], [':', 'x']]]\n</code></pre>"},{"location":"getting-started/quickstart/#distributive-rule","title":"Distributive Rule","text":"<pre><code># x * (y + z) = x*y + x*z\n[['*', ['?', 'x'], ['+', ['?', 'y'], ['?', 'z']]],\n ['+', ['*', [':', 'x'], [':', 'y']], ['*', [':', 'x'], [':', 'z']]]]\n</code></pre>"},{"location":"getting-started/quickstart/#using-predefined-rules","title":"Using Predefined Rules","text":"<p>XTK comes with many predefined mathematical rules:</p> <pre><code>from xtk.rule_loader import load_rules\n\n# Load derivative rules\nderiv_rules = load_rules('src/xtk/rules/deriv_rules.py')\n\n# Load algebra rules\nalgebra_rules = load_rules('src/xtk/rules/algebra_rules.py')\n</code></pre>"},{"location":"getting-started/quickstart/#example-symbolic-differentiation","title":"Example: Symbolic Differentiation","text":"<pre><code>from xtk import rewriter\nfrom xtk.rule_loader import load_rules\n\n# Load derivative rules\nrules = load_rules('src/xtk/rules/deriv_rules.py')\ndiff = rewriter(rules)\n\n# Differentiate x^2\nexpr = ['dd', ['^', 'x', 2], 'x']\nresult = diff(expr)\nprint(result)  # ['*', 2, ['^', 'x', 1]]\n</code></pre>"},{"location":"getting-started/quickstart/#expression-representation","title":"Expression Representation","text":"<p>XTK uses nested lists (AST) to represent expressions:</p> Mathematical Notation XTK Representation \\(x + 3\\) <code>['+', 'x', 3]</code> \\(2 \\times x\\) <code>['*', 2, 'x']</code> \\(x^2\\) <code>['^', 'x', 2]</code> \\(\\sin(x)\\) <code>['sin', 'x']</code> \\(\\frac{d}{dx}(x^2)\\) <code>['dd', ['^', 'x', 2], 'x']</code>"},{"location":"getting-started/quickstart/#simplification","title":"Simplification","text":"<p>To simplify expressions recursively:</p> <pre><code>from xtk.simplifier import simplifier\n\nrules = [\n    [['+', ['?', 'x'], 0], [':', 'x']],\n    [['*', ['?', 'x'], 0], 0],\n    [['*', ['?', 'x'], 1], [':', 'x']],\n]\n\nsimplify = simplifier(rules)\n\n# Simplify nested expression\nexpr = ['+', ['*', 'x', 1], 0]\nresult = simplify(expr)\nprint(result)  # 'x'\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you've learned the basics, explore:</p> <ul> <li>Core Concepts - Deeper understanding of XTK's architecture</li> <li>Pattern Matching - Advanced pattern matching techniques</li> <li>Examples - Real-world examples</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"getting-started/quickstart/#common-patterns","title":"Common Patterns","text":""},{"location":"getting-started/quickstart/#chain-multiple-rules","title":"Chain Multiple Rules","text":"<pre><code>rules = [\n    [['+', ['?', 'x'], 0], [':', 'x']],      # x + 0 = x\n    [['+', 0, ['?', 'x']], [':', 'x']],      # 0 + x = x\n    [['*', ['?', 'x'], 1], [':', 'x']],      # x * 1 = x\n    [['*', 1, ['?', 'x']], [':', 'x']],      # 1 * x = x\n    [['*', ['?', 'x'], 0], 0],               # x * 0 = 0\n    [['*', 0, ['?', 'x']], 0],               # 0 * x = 0\n]\n</code></pre>"},{"location":"getting-started/quickstart/#conditional-rules","title":"Conditional Rules","text":"<p>Use pattern constraints to create conditional rules:</p> <pre><code># Only match if x and y are the same\n[['dd', ['?v', 'x'], ['?v', 'x']], 1]  # d(x)/dx = 1\n</code></pre>"},{"location":"getting-started/quickstart/#tips","title":"Tips","text":"<ol> <li>Start Simple: Begin with simple rules and build up complexity</li> <li>Use the REPL: Test rules interactively before coding</li> <li>Check Order: Rule order matters - more specific rules should come first</li> <li>Debug: Use logging or print bindings to see what matched</li> <li>Test: Write tests for your custom rules</li> </ol> <p>Ready to dive deeper? Continue to the Interactive REPL Guide!</p>"},{"location":"getting-started/repl/","title":"Interactive REPL Guide","text":"<p>The XTK REPL (Read-Eval-Print Loop) provides an interactive environment for exploring symbolic expressions with rich visualizations and step-by-step transformation tracking.</p>"},{"location":"getting-started/repl/#starting-the-repl","title":"Starting the REPL","text":"<p>Launch the REPL from the command line:</p> <pre><code>python -m xtk.cli\n</code></pre> <p>Or if you installed XTK globally:</p> <pre><code>xtk\n</code></pre> <p>You'll see the prompt:</p> <pre><code>xtk&gt;\n</code></pre>"},{"location":"getting-started/repl/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/repl/#entering-expressions","title":"Entering Expressions","text":"<p>Expressions can be entered in S-expression or infix notation:</p> S-expressionInfix <pre><code>xtk&gt; (+ 2 3)\nExpression: ['+', 2, 3]\n</code></pre> <pre><code>xtk&gt; 2 + 3\nExpression: ['+', 2, 3]\n</code></pre>"},{"location":"getting-started/repl/#rewriting-expressions","title":"Rewriting Expressions","text":"<p>Use <code>/rewrite</code> or <code>/rw</code> to apply loaded rules:</p> <pre><code>xtk&gt; (+ x 0)\nExpression: ['+', 'x', 0]\n\nxtk&gt; /rewrite\nRewritten: x\n</code></pre>"},{"location":"getting-started/repl/#tree-visualization","title":"Tree Visualization","text":"<p>Display expressions as trees with <code>/tree</code>:</p> <pre><code>xtk&gt; (* (+ x 2) (- y 1))\nExpression: ['*', ['+', 'x', 2], ['-', 'y', 1]]\n\nxtk&gt; /tree\n*\n\u251c\u2500\u2500 +\n\u2502   \u251c\u2500\u2500 x\n\u2502   \u2514\u2500\u2500 2\n\u2514\u2500\u2500 -\n    \u251c\u2500\u2500 y\n    \u2514\u2500\u2500 1\n</code></pre>"},{"location":"getting-started/repl/#repl-commands","title":"REPL Commands","text":""},{"location":"getting-started/repl/#expression-management","title":"Expression Management","text":"Command Alias Description <code>/expr</code> <code>/e</code> Show current expression <code>/tree</code> <code>/t</code> Display expression tree <code>/clear</code> <code>/c</code> Clear current expression"},{"location":"getting-started/repl/#transformation","title":"Transformation","text":"Command Alias Description <code>/rewrite</code> <code>/rw</code> Apply rewrite rules <code>/simplify</code> <code>/s</code> Simplify expression <code>/eval</code> Evaluate expression <code>/step</code> Show step-by-step transformation"},{"location":"getting-started/repl/#rule-management","title":"Rule Management","text":"Command Example Description <code>/rules load &lt;file&gt;</code> <code>/rules load deriv_rules.py</code> Load rules from file <code>/rules list</code> List loaded rules <code>/rules clear</code> Clear all rules <code>/rules show &lt;n&gt;</code> <code>/rules show 5</code> Show specific rule"},{"location":"getting-started/repl/#display-options","title":"Display Options","text":"Command Description <code>/format s-expr</code> Use S-expression format <code>/format infix</code> Use infix format <code>/format tree</code> Always show tree view <code>/trace on</code> Enable step-by-step tracing <code>/trace off</code> Disable tracing"},{"location":"getting-started/repl/#utility","title":"Utility","text":"Command Description <code>/help</code> Show help message <code>/exit</code> Exit the REPL <code>/history</code> Show command history <code>/save &lt;file&gt;</code> Save session to file"},{"location":"getting-started/repl/#working-with-rules","title":"Working with Rules","text":""},{"location":"getting-started/repl/#loading-predefined-rules","title":"Loading Predefined Rules","text":"<p>XTK includes many predefined rule sets:</p> <pre><code>xtk&gt; /rules load src/xtk/rules/deriv_rules.py\nLoaded 15 derivative rules\n\nxtk&gt; /rules load src/xtk/rules/algebra_rules.py\nLoaded 23 algebra rules\n</code></pre>"},{"location":"getting-started/repl/#viewing-loaded-rules","title":"Viewing Loaded Rules","text":"<pre><code>xtk&gt; /rules list\n1. dd (?c c) (?v x) =&gt; 0\n2. dd (?v x) (?v x) =&gt; 1\n3. dd (+ (? f) (? g)) (?v x) =&gt; (+ (dd (: f) (: x)) (dd (: g) (: x)))\n...\n</code></pre>"},{"location":"getting-started/repl/#viewing-specific-rules","title":"Viewing Specific Rules","text":"<pre><code>xtk&gt; /rules show 3\nRule 3: Sum Rule\nPattern: ['dd', ['+', ['?', 'f'], ['?', 'g']], ['?v', 'x']]\nReplacement: ['+', ['dd', [':', 'f'], [':', 'x']], ['dd', [':', 'g'], [':', 'x']]]\nDescription: d(f+g)/dx = df/dx + dg/dx\n</code></pre>"},{"location":"getting-started/repl/#example-sessions","title":"Example Sessions","text":""},{"location":"getting-started/repl/#symbolic-differentiation","title":"Symbolic Differentiation","text":"<pre><code>xtk&gt; /rules load src/xtk/rules/deriv_rules.py\nLoaded 15 derivative rules\n\nxtk&gt; (dd (^ x 2) x)\nExpression: ['dd', ['^', 'x', 2], 'x']\n\nxtk&gt; /rewrite\nRewritten: ['*', 2, ['^', 'x', 1]]\n\nxtk&gt; /rewrite\nRewritten: ['*', 2, 'x']\n</code></pre>"},{"location":"getting-started/repl/#algebraic-simplification","title":"Algebraic Simplification","text":"<pre><code>xtk&gt; /rules load src/xtk/rules/algebra_rules.py\n\nxtk&gt; (* (+ x 0) 1)\nExpression: ['*', ['+', 'x', 0], 1]\n\nxtk&gt; /simplify\nSimplified: x\n</code></pre>"},{"location":"getting-started/repl/#step-by-step-transformation","title":"Step-by-Step Transformation","text":"<pre><code>xtk&gt; /trace on\n\nxtk&gt; (dd (* x x) x)\nExpression: ['dd', ['*', 'x', 'x'], 'x']\n\nxtk&gt; /step\nStep 1: Applied \"Product Rule\"\n  Pattern: ['dd', ['*', ['?', 'f'], ['?', 'g']], ['?v', 'x']]\n  Result: ['+', ['*', ['dd', 'x', 'x'], 'x'], ['*', 'x', ['dd', 'x', 'x']]]\n\nxtk&gt; /step\nStep 2: Applied \"Variable Derivative\"\n  Pattern: ['dd', ['?v', 'x'], ['?v', 'x']]\n  Result: ['+', ['*', 1, 'x'], ['*', 'x', 1]]\n\nxtk&gt; /step\nStep 3: Applied \"Multiplication Identity\"\n  Pattern: ['*', 1, ['?', 'x']]\n  Result: ['+', 'x', 'x']\n</code></pre>"},{"location":"getting-started/repl/#advanced-features","title":"Advanced Features","text":""},{"location":"getting-started/repl/#expression-history","title":"Expression History","text":"<p>Navigate through previous expressions:</p> <pre><code>xtk&gt; (+ 2 3)\nxtk&gt; (* 4 5)\nxtk&gt; /history\n1. ['+', 2, 3]\n2. ['*', 4, 5]\n\nxtk&gt; !1\nExpression: ['+', 2, 3]\n</code></pre>"},{"location":"getting-started/repl/#saving-sessions","title":"Saving Sessions","text":"<p>Save your work to replay later:</p> <pre><code>xtk&gt; /save my_session.xtk\nSession saved to my_session.xtk\n\n# Later...\nxtk&gt; /load my_session.xtk\nSession loaded\n</code></pre>"},{"location":"getting-started/repl/#custom-bindings","title":"Custom Bindings","text":"<p>Define custom functions and variables:</p> <pre><code>xtk&gt; /bind f (lambda x (+ x 1))\nxtk&gt; /bind a 42\n\nxtk&gt; (f a)\nExpression: ['f', 42]\n\nxtk&gt; /eval\nResult: 43\n</code></pre>"},{"location":"getting-started/repl/#configuration","title":"Configuration","text":""},{"location":"getting-started/repl/#customizing-the-repl","title":"Customizing the REPL","text":"<p>Create a <code>.xtkrc</code> file in your home directory:</p> <pre><code># ~/.xtkrc\n{\n    \"auto_simplify\": true,\n    \"format\": \"infix\",\n    \"trace\": false,\n    \"prompt\": \"xtk&gt; \",\n    \"theme\": \"monokai\"\n}\n</code></pre>"},{"location":"getting-started/repl/#color-themes","title":"Color Themes","text":"<p>Available themes: - <code>monokai</code> (default) - <code>solarized-light</code> - <code>solarized-dark</code> - <code>github</code> - <code>nord</code></p> <p>Set with:</p> <pre><code>xtk&gt; /theme nord\nTheme changed to nord\n</code></pre>"},{"location":"getting-started/repl/#tips-and-tricks","title":"Tips and Tricks","text":""},{"location":"getting-started/repl/#1-auto-completion","title":"1. Auto-completion","text":"<p>Use Tab to auto-complete:</p> <pre><code>xtk&gt; /ru&lt;TAB&gt;\n/rules\n\nxtk&gt; /rules lo&lt;TAB&gt;\n/rules load\n</code></pre>"},{"location":"getting-started/repl/#2-quick-evaluation","title":"2. Quick Evaluation","text":"<p>Add <code>!</code> to evaluate immediately:</p> <pre><code>xtk&gt; (+ 2 3)!\nResult: 5\n</code></pre>"},{"location":"getting-started/repl/#3-pipe-to-external-tools","title":"3. Pipe to External Tools","text":"<p>Export expressions to external tools:</p> <pre><code>xtk&gt; (^ x 2) | /export latex\nOutput: x^{2}\n\nxtk&gt; (^ x 2) | /export python\nOutput: x**2\n</code></pre>"},{"location":"getting-started/repl/#4-multi-line-input","title":"4. Multi-line Input","text":"<p>Use <code>\\</code> for multi-line expressions:</p> <pre><code>xtk&gt; (+ \\\n...    x \\\n...    y \\\n...    z)\nExpression: ['+', 'x', 'y', 'z']\n</code></pre>"},{"location":"getting-started/repl/#5-batch-processing","title":"5. Batch Processing","text":"<p>Process multiple expressions:</p> <pre><code>cat expressions.txt | python -m xtk.cli --batch\n</code></pre>"},{"location":"getting-started/repl/#keyboard-shortcuts","title":"Keyboard Shortcuts","text":"Shortcut Action Ctrl+C Cancel current input Ctrl+D Exit REPL Up/Down Navigate history Tab Auto-complete Ctrl+R Reverse search history Ctrl+L Clear screen"},{"location":"getting-started/repl/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/repl/#expression-not-simplifying","title":"Expression Not Simplifying","text":"<p>If an expression isn't simplifying:</p> <ol> <li>Check that appropriate rules are loaded: <code>/rules list</code></li> <li>Enable tracing to see what's happening: <code>/trace on</code></li> <li>Try simplifying sub-expressions first</li> <li>Verify rule patterns match your expression</li> </ol>"},{"location":"getting-started/repl/#rules-not-loading","title":"Rules Not Loading","text":"<p>If rules fail to load:</p> <ol> <li>Check the file path is correct</li> <li>Ensure the file contains valid Python</li> <li>Look for syntax errors in rule definitions</li> <li>Check permissions on the file</li> </ol>"},{"location":"getting-started/repl/#performance-issues","title":"Performance Issues","text":"<p>For large expressions:</p> <ol> <li>Disable tracing: <code>/trace off</code></li> <li>Disable auto-simplification in config</li> <li>Use more specific rules</li> <li>Consider breaking into smaller sub-problems</li> </ol>"},{"location":"getting-started/repl/#next-steps","title":"Next Steps","text":"<ul> <li>Explore Pattern Matching in depth</li> <li>Learn about Custom Rules</li> <li>See Examples for real-world use cases</li> </ul>"},{"location":"user-guide/concepts/","title":"Core Concepts","text":"<p>Understanding XTK's core concepts is essential for effective use of the toolkit. This guide explains the fundamental ideas behind XTK's design and operation.</p>"},{"location":"user-guide/concepts/#the-big-picture","title":"The Big Picture","text":"<p>XTK is built around three fundamental operations:</p> <pre><code>graph LR\n    A[Expression] --&gt; B[Match]\n    B --&gt; C[Instantiate]\n    C --&gt; D[Evaluate]\n    D --&gt; E[Simplified Expression]\n    E -.-&gt; A</code></pre> <ol> <li>Match: Find patterns in expressions</li> <li>Instantiate: Create new expressions from patterns</li> <li>Evaluate: Compute values and simplify</li> </ol>"},{"location":"user-guide/concepts/#abstract-syntax-trees-ast","title":"Abstract Syntax Trees (AST)","text":"<p>XTK represents all expressions as Abstract Syntax Trees using nested Python lists.</p>"},{"location":"user-guide/concepts/#why-asts","title":"Why ASTs?","text":"<p>ASTs provide a uniform representation for:</p> <ul> <li>Mathematical expressions</li> <li>Function applications</li> <li>Operations</li> <li>Variables and constants</li> </ul>"},{"location":"user-guide/concepts/#ast-structure","title":"AST Structure","text":"<p>Each AST node is either:</p> <ul> <li>Atomic: A constant or variable (e.g., <code>42</code>, <code>'x'</code>)</li> <li>Compound: A list with an operator and operands (e.g., <code>['+', 2, 3]</code>)</li> </ul>"},{"location":"user-guide/concepts/#examples","title":"Examples","text":"Expression AST Representation Python Equivalent \\(5\\) <code>5</code> <code>5</code> \\(x\\) <code>'x'</code> <code>x</code> \\(x + 3\\) <code>['+', 'x', 3]</code> <code>x + 3</code> \\(2 \\times (x + 1)\\) <code>['*', 2, ['+', 'x', 1]]</code> <code>2 * (x + 1)</code> \\(\\sin(x)\\) <code>['sin', 'x']</code> <code>sin(x)</code> \\(f(x, y)\\) <code>['f', 'x', 'y']</code> <code>f(x, y)</code>"},{"location":"user-guide/concepts/#pattern-matching","title":"Pattern Matching","text":"<p>Pattern matching is the process of determining if an expression has a certain structure.</p>"},{"location":"user-guide/concepts/#pattern-syntax","title":"Pattern Syntax","text":"<p>XTK uses special markers to create flexible patterns:</p> Pattern Matches Example <code>['?', 'x']</code> Any expression Matches <code>5</code>, <code>'a'</code>, <code>['+', 2, 3]</code> <code>['?c', 'c']</code> Any constant Matches <code>5</code>, <code>3.14</code>, <code>-7</code> <code>['?v', 'x']</code> Any variable Matches <code>'x'</code>, <code>'foo'</code> <code>42</code> Exact value Matches only <code>42</code> <code>'+'</code> Exact symbol Matches only <code>'+'</code>"},{"location":"user-guide/concepts/#how-matching-works","title":"How Matching Works","text":"<p>When matching a pattern against an expression:</p> <ol> <li>Atomic matching: Constants and variables must match exactly</li> <li>List matching: Lists must have the same structure</li> <li>Pattern variables: Bind to sub-expressions</li> </ol> <p>Example:</p> <pre><code>pattern = ['+', ['?', 'x'], ['?', 'y']]\nexpr = ['+', 2, 3]\n\n# Matching produces bindings:\n# {'x': 2, 'y': 3}\n</code></pre>"},{"location":"user-guide/concepts/#nested-patterns","title":"Nested Patterns","text":"<p>Patterns can be nested arbitrarily deep:</p> <pre><code>pattern = ['dd', ['*', ['?', 'f'], ['?', 'g']], ['?v', 'x']]\n# Matches differentiation of products: d(f*g)/dx\n</code></pre>"},{"location":"user-guide/concepts/#rewrite-rules","title":"Rewrite Rules","text":"<p>A rewrite rule transforms expressions from one form to another.</p>"},{"location":"user-guide/concepts/#rule-structure","title":"Rule Structure","text":"<p>Each rule consists of two parts:</p> <pre><code>[pattern, skeleton]\n</code></pre> <ul> <li>Pattern: What to match</li> <li>Skeleton: What to replace with</li> </ul>"},{"location":"user-guide/concepts/#example-rules","title":"Example Rules","text":"<pre><code># Additive identity: x + 0 = x\n[['+', ['?', 'x'], 0], [':', 'x']]\n\n# Multiplicative identity: x * 1 = x\n[['*', ['?', 'x'], 1], [':', 'x']]\n\n# Derivative of constant: d(c)/dx = 0\n[['dd', ['?c', 'c'], ['?v', 'x']], 0]\n\n# Power rule: d(x^n)/dx = n*x^(n-1)\n[['dd', ['^', ['?v', 'x'], ['?c', 'n']], ['?v', 'x']],\n ['*', [':', 'n'], ['^', [':', 'x'], ['-', [':', 'n'], 1]]]]\n</code></pre>"},{"location":"user-guide/concepts/#skeleton-instantiation","title":"Skeleton Instantiation","text":"<p>The skeleton uses <code>:</code> to reference matched variables:</p> <pre><code>pattern = ['+', ['?', 'x'], ['?', 'y']]\nskeleton = ['+', [':', 'y'], [':', 'x']]  # Swap x and y\n\n# Applied to ['+', 2, 3]:\n# x matches 2, y matches 3\n# Skeleton becomes ['+', 3, 2]\n</code></pre>"},{"location":"user-guide/concepts/#bindings","title":"Bindings","text":"<p>Bindings are dictionaries that map variable names to values.</p>"},{"location":"user-guide/concepts/#pattern-bindings","title":"Pattern Bindings","text":"<p>Created during matching:</p> <pre><code>pattern = ['*', ['?', 'a'], ['?', 'b']]\nexpr = ['*', 2, 'x']\n\nbindings = match(pattern, expr, {})\n# Result: {'a': 2, 'b': 'x'}\n</code></pre>"},{"location":"user-guide/concepts/#evaluation-bindings","title":"Evaluation Bindings","text":"<p>Used during evaluation:</p> <pre><code>bindings = {\n    '+': lambda x, y: x + y,\n    '*': lambda x, y: x * y,\n    'x': 5,\n    'y': 3\n}\n\nexpr = ['+', ['*', 'x', 'y'], 1]\nresult = evaluate(expr, bindings)\n# Result: 16  (5*3 + 1)\n</code></pre>"},{"location":"user-guide/concepts/#simplification","title":"Simplification","text":"<p>Simplification applies rewrite rules recursively to reduce expressions.</p>"},{"location":"user-guide/concepts/#bottom-up-simplification","title":"Bottom-Up Simplification","text":"<p>XTK simplifies from the leaves to the root:</p> <pre><code>expr = ['+', ['*', 'x', 1], 0]\n\n# Step 1: Simplify ['*', 'x', 1] =&gt; 'x'\n# Step 2: Simplify ['+', 'x', 0] =&gt; 'x'\n# Result: 'x'\n</code></pre>"},{"location":"user-guide/concepts/#fixed-point","title":"Fixed Point","text":"<p>Simplification continues until no more rules apply:</p> <pre><code>expr = ['+', ['+', 'x', 0], ['*', 'y', 1]]\n\n# Apply rules until expression stops changing\n# Result: ['+', 'x', 'y']\n</code></pre>"},{"location":"user-guide/concepts/#evaluation","title":"Evaluation","text":"<p>Evaluation computes concrete values from symbolic expressions.</p>"},{"location":"user-guide/concepts/#evaluation-process","title":"Evaluation Process","text":"<ol> <li>Lookup variables: Replace variables with their values</li> <li>Apply operations: Call functions with their arguments</li> <li>Return result: The final computed value</li> </ol>"},{"location":"user-guide/concepts/#example","title":"Example","text":"<pre><code>from xtk.rewriter import evaluate\n\nexpr = ['+', ['*', 2, 'x'], 3]\nbindings = {\n    '+': lambda a, b: a + b,\n    '*': lambda a, b: a * b,\n    'x': 5\n}\n\nresult = evaluate(expr, bindings)\n# 2*5 + 3 = 13\n</code></pre>"},{"location":"user-guide/concepts/#expression-spaces","title":"Expression Spaces","text":"<p>An expression space is the set of all expressions reachable from an initial expression by applying rules.</p>"},{"location":"user-guide/concepts/#state-space-graph","title":"State Space Graph","text":"<pre><code>graph TD\n    A[\"x^2 - 1\"] --&gt; B[\"(x-1)(x+1)\"]\n    A --&gt; C[\"x*x - 1\"]\n    C --&gt; D[\"x*x - 1*1\"]\n    D --&gt; B</code></pre> <p>Each node is an expression, edges are rule applications.</p>"},{"location":"user-guide/concepts/#search-strategies","title":"Search Strategies","text":"<p>Different algorithms explore this space:</p> <ul> <li>BFS: Level by level</li> <li>DFS: Deep first, then backtrack</li> <li>Best-First: Use heuristics to guide search</li> <li>A*: Optimal pathfinding</li> </ul>"},{"location":"user-guide/concepts/#turing-completeness","title":"Turing Completeness","text":"<p>XTK's rule system is Turing-complete, meaning it can express any computable function.</p>"},{"location":"user-guide/concepts/#implications","title":"Implications","text":"<ol> <li>Unlimited power: Can implement any algorithm</li> <li>Halting problem: Some rewrites may not terminate</li> <li>Careful design: Need to ensure rules terminate</li> </ol>"},{"location":"user-guide/concepts/#example-computing-factorial","title":"Example: Computing Factorial","text":"<pre><code>rules = [\n    # Base case: fact(0) = 1\n    [['fact', 0], 1],\n\n    # Recursive case: fact(n) = n * fact(n-1)\n    [['fact', ['?c', 'n']],\n     ['*', [':', 'n'], ['fact', ['-', [':', 'n'], 1]]]]\n]\n</code></pre>"},{"location":"user-guide/concepts/#rule-ordering","title":"Rule Ordering","text":"<p>The order of rules matters!</p>"},{"location":"user-guide/concepts/#first-match-wins","title":"First Match Wins","text":"<p>XTK applies the first matching rule:</p> <pre><code>rules = [\n    [['?c', 'x'], 'constant'],  # Too general!\n    [['+', ['?', 'x'], 0], [':', 'x']]\n]\n\n# This will always match the first rule\nexpr = ['+', 'a', 0]\n# Result: 'constant' (not what we want!)\n</code></pre>"},{"location":"user-guide/concepts/#best-practice","title":"Best Practice","text":"<p>Place more specific rules before general ones:</p> <pre><code>rules = [\n    [['+', ['?', 'x'], 0], [':', 'x']],      # Specific\n    [['*', ['?', 'x'], 1], [':', 'x']],      # Specific\n    [['?c', 'x'], ['constant', [':', 'x']]]  # General\n]\n</code></pre>"},{"location":"user-guide/concepts/#type-system","title":"Type System","text":"<p>While Python is dynamically typed, XTK's patterns provide a form of type checking.</p>"},{"location":"user-guide/concepts/#pattern-types","title":"Pattern Types","text":"<ul> <li><code>['?c', 'x']</code> - Only matches constants</li> <li><code>['?v', 'x']</code> - Only matches variables</li> <li><code>['?', 'x']</code> - Matches anything</li> </ul>"},{"location":"user-guide/concepts/#example_1","title":"Example","text":"<pre><code># This rule only applies to derivatives of constants\n[['dd', ['?c', 'c'], ['?v', 'x']], 0]\n\n# Won't match: ['dd', ['+', 'x', 'y'], 'x']\n# Because ['+', 'x', 'y'] is not a constant\n</code></pre>"},{"location":"user-guide/concepts/#compositionality","title":"Compositionality","text":"<p>XTK rules compose naturally.</p>"},{"location":"user-guide/concepts/#building-complex-behavior","title":"Building Complex Behavior","text":"<p>Small, simple rules combine to solve complex problems:</p> <pre><code># Simple rules\nidentity_rules = [\n    [['+', ['?', 'x'], 0], [':', 'x']],\n    [['*', ['?', 'x'], 1], [':', 'x']],\n]\n\nderivative_rules = [\n    [['dd', ['?c', 'c'], ['?v', 'x']], 0],\n    [['dd', ['?v', 'x'], ['?v', 'x']], 1],\n    # ... more rules\n]\n\n# Combine them\nall_rules = identity_rules + derivative_rules\n</code></pre>"},{"location":"user-guide/concepts/#emergent-behavior","title":"Emergent Behavior","text":"<p>Complex simplifications emerge from simple rules:</p> <pre><code>expr = ['dd', ['+', ['*', 'x', 1], 0], 'x']\n\n# Applies multiple rules in sequence:\n# 1. Simplify x*1 =&gt; x\n# 2. Simplify x+0 =&gt; x\n# 3. Differentiate dd(x, x) =&gt; 1\n# Result: 1\n</code></pre>"},{"location":"user-guide/concepts/#declarative-programming","title":"Declarative Programming","text":"<p>XTK follows a declarative paradigm:</p> <ul> <li>Describe what, not how</li> <li>Rules define transformations</li> <li>System determines application order</li> </ul>"},{"location":"user-guide/concepts/#imperative-vs-declarative","title":"Imperative vs Declarative","text":"ImperativeDeclarative <pre><code>def simplify_add(expr):\n    if expr[0] == '+':\n        if expr[2] == 0:\n            return expr[1]\n    return expr\n</code></pre> <pre><code>rules = [\n    [['+', ['?', 'x'], 0], [':', 'x']]\n]\n</code></pre> <p>The declarative approach is more concise and composable.</p>"},{"location":"user-guide/concepts/#next-steps","title":"Next Steps","text":"<p>Now that you understand the core concepts:</p> <ul> <li>Learn about Expression Representation in detail</li> <li>Master Pattern Matching</li> <li>Explore Rewrite Rules</li> <li>Try Tree Search Algorithms</li> </ul>"},{"location":"user-guide/expressions/","title":"Expression Representation","text":"<p>This guide explains how XTK represents expressions using Abstract Syntax Trees (ASTs).</p>"},{"location":"user-guide/expressions/#the-ast-model","title":"The AST Model","text":"<p>XTK uses nested Python lists to represent expressions. This simple yet powerful representation makes expressions easy to construct, manipulate, and understand.</p>"},{"location":"user-guide/expressions/#why-lists","title":"Why Lists?","text":"<p>Using nested lists for ASTs offers several advantages:</p> <ol> <li>Simplicity: No complex class hierarchies to learn</li> <li>Familiarity: Python programmers already know lists</li> <li>Transparency: You can see exactly what's in an expression</li> <li>Serialization: Easy to save/load (JSON, pickle, etc.)</li> <li>Flexibility: Works with any domain</li> </ol>"},{"location":"user-guide/expressions/#basic-structure","title":"Basic Structure","text":""},{"location":"user-guide/expressions/#atomic-expressions","title":"Atomic Expressions","text":"<p>Atomic expressions are the building blocks:</p> <pre><code># Constants (numbers)\n42\n3.14\n-7\n2.5e10\n\n# Variables (strings)\n'x'\n'y'\n'alpha'\n'foo'\n</code></pre>"},{"location":"user-guide/expressions/#compound-expressions","title":"Compound Expressions","text":"<p>Compound expressions are lists with an operator and operands:</p> <pre><code>[operator, operand1, operand2, ...]\n</code></pre>"},{"location":"user-guide/expressions/#examples","title":"Examples","text":""},{"location":"user-guide/expressions/#arithmetic","title":"Arithmetic","text":"Mathematical XTK Representation \\(5\\) <code>5</code> \\(x\\) <code>'x'</code> \\(x + 3\\) <code>['+', 'x', 3]</code> \\(2 \\times x\\) <code>['*', 2, 'x']</code> \\(x - y\\) <code>['-', 'x', 'y']</code> \\(\\frac{x}{2}\\) <code>['/', 'x', 2]</code>"},{"location":"user-guide/expressions/#powers-and-roots","title":"Powers and Roots","text":"Mathematical XTK Representation \\(x^2\\) <code>['^', 'x', 2]</code> \\(x^n\\) <code>['^', 'x', 'n']</code> \\(\\sqrt{x}\\) <code>['^', 'x', 0.5]</code> or <code>['sqrt', 'x']</code> \\(\\sqrt[3]{x}\\) <code>['^', 'x', ['/', 1, 3]]</code>"},{"location":"user-guide/expressions/#functions","title":"Functions","text":"Mathematical XTK Representation \\(\\sin(x)\\) <code>['sin', 'x']</code> \\(\\cos(x)\\) <code>['cos', 'x']</code> \\(\\ln(x)\\) <code>['ln', 'x']</code> \\(e^x\\) <code>['^', 'e', 'x']</code> \\(f(x, y)\\) <code>['f', 'x', 'y']</code>"},{"location":"user-guide/expressions/#calculus","title":"Calculus","text":"Mathematical XTK Representation \\(\\frac{d}{dx}(x^2)\\) <code>['dd', ['^', 'x', 2], 'x']</code> \\(\\int x\\,dx\\) <code>['int', 'x', 'x']</code> \\(\\lim_{x \\to 0} f(x)\\) <code>['lim', ['f', 'x'], 'x', 0]</code>"},{"location":"user-guide/expressions/#nested-expressions","title":"Nested Expressions","text":"<p>Complex expressions are built by nesting:</p> <pre><code># (x + 3) * 4\n['*', ['+', 'x', 3], 4]\n\n# sin(x^2)\n['sin', ['^', 'x', 2]]\n\n# (x + y)^2\n['^', ['+', 'x', 'y'], 2]\n\n# (2*x + 1) / (x - 3)\n['/', ['+', ['*', 2, 'x'], 1], ['-', 'x', 3]]\n</code></pre>"},{"location":"user-guide/expressions/#tree-structure","title":"Tree Structure","text":"<p>Expressions form tree structures:</p> <pre><code>    *\n   / \\\n  +   4\n / \\\nx   3\n</code></pre> <p>This represents <code>['*', ['+', 'x', 3], 4]</code> or \\((x + 3) \\times 4\\).</p>"},{"location":"user-guide/expressions/#walking-the-tree","title":"Walking the Tree","text":"<pre><code>def walk(expr):\n    \"\"\"Recursively walk an expression tree.\"\"\"\n    if isinstance(expr, list):\n        operator = expr[0]\n        operands = expr[1:]\n        print(f\"Operator: {operator}\")\n        for operand in operands:\n            walk(operand)\n    else:\n        print(f\"Atom: {expr}\")\n\n# Example\nexpr = ['*', ['+', 'x', 3], 4]\nwalk(expr)\n# Output:\n# Operator: *\n# Operator: +\n# Atom: x\n# Atom: 3\n# Atom: 4\n</code></pre>"},{"location":"user-guide/expressions/#type-system","title":"Type System","text":"<p>XTK distinguishes between three types of atomic values:</p>"},{"location":"user-guide/expressions/#constants","title":"Constants","text":"<p>Numbers (integers and floats):</p> <pre><code>42      # Integer constant\n3.14    # Float constant\n-7      # Negative constant\n2.5e10  # Scientific notation\n</code></pre>"},{"location":"user-guide/expressions/#variables","title":"Variables","text":"<p>Strings representing symbolic variables:</p> <pre><code>'x'     # Variable x\n'y'     # Variable y\n'alpha' # Greek letter alpha\n'foo'   # Any identifier\n</code></pre>"},{"location":"user-guide/expressions/#operators","title":"Operators","text":"<p>The first element of a list is typically an operator:</p> <pre><code>'+'     # Addition\n'*'     # Multiplication\n'sin'   # Sine function\n'dd'    # Derivative operator\n</code></pre>"},{"location":"user-guide/expressions/#constructing-expressions","title":"Constructing Expressions","text":""},{"location":"user-guide/expressions/#manually","title":"Manually","text":"<p>Build expressions directly:</p> <pre><code># x + 3\nexpr = ['+', 'x', 3]\n\n# 2*x^2 + 3*x + 1\npoly = ['+',\n    ['+',\n        ['*', 2, ['^', 'x', 2]],\n        ['*', 3, 'x']\n    ],\n    1\n]\n</code></pre>"},{"location":"user-guide/expressions/#programmatically","title":"Programmatically","text":"<p>Build expressions with helper functions:</p> <pre><code>def binary_op(op, left, right):\n    return [op, left, right]\n\ndef power(base, exp):\n    return ['^', base, exp]\n\n# x^2 + y^2\nexpr = binary_op('+', power('x', 2), power('y', 2))\n</code></pre>"},{"location":"user-guide/expressions/#from-parser","title":"From Parser","text":"<p>Parse string representations (if parser is available):</p> <pre><code>from xtk.parser import parse\n\nexpr = parse(\"2*x + 3\")\n# Returns: ['+', ['*', 2, 'x'], 3]\n</code></pre>"},{"location":"user-guide/expressions/#inspecting-expressions","title":"Inspecting Expressions","text":""},{"location":"user-guide/expressions/#type-checking","title":"Type Checking","text":"<pre><code>from xtk.rewriter import constant, variable, compound\n\nconstant(42)              # True\nconstant('x')             # False\n\nvariable('x')             # True\nvariable(42)              # False\n\ncompound(['+', 2, 3])     # True\ncompound(42)              # False\n</code></pre>"},{"location":"user-guide/expressions/#decomposition","title":"Decomposition","text":"<pre><code>from xtk.rewriter import car, cdr\n\nexpr = ['+', 'x', 'y']\n\noperator = car(expr)      # '+'\noperands = cdr(expr)      # ['x', 'y']\n\nfirst_operand = car(operands)   # 'x'\nsecond_operand = car(cdr(operands))  # 'y'\n</code></pre>"},{"location":"user-guide/expressions/#expression-equality","title":"Expression Equality","text":""},{"location":"user-guide/expressions/#structural-equality","title":"Structural Equality","text":"<p>Python's <code>==</code> checks structural equality:</p> <pre><code>expr1 = ['+', 'x', 3]\nexpr2 = ['+', 'x', 3]\nexpr1 == expr2  # True\n\nexpr3 = ['+', 3, 'x']\nexpr1 == expr3  # False (different order)\n</code></pre>"},{"location":"user-guide/expressions/#semantic-equality","title":"Semantic Equality","text":"<p>To check semantic equality, you need to normalize:</p> <pre><code>from xtk.simplifier import simplifier\n\nrules = [...]  # Normalization rules\nsimplify = simplifier(rules)\n\nexpr1 = ['+', 'x', 0]\nexpr2 = 'x'\n\nsimplify(expr1) == simplify(expr2)  # True\n</code></pre>"},{"location":"user-guide/expressions/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/expressions/#1-use-consistent-operators","title":"1. Use Consistent Operators","text":"<p>Choose standard operators and stick to them:</p> <pre><code># Good: standard operator names\n['+', 'x', 'y']\n['*', 2, 'x']\n\n# Avoid: non-standard names\n['add', 'x', 'y']\n['times', 2, 'x']\n</code></pre>"},{"location":"user-guide/expressions/#2-maintain-tree-structure","title":"2. Maintain Tree Structure","text":"<p>Keep expressions as trees, not graphs:</p> <pre><code># Good: tree structure\n['+', ['*', 'x', 2], ['*', 'y', 3]]\n\n# Avoid: shared sub-expressions (unless intentional)\nshared = ['*', 'x', 2]\n['+', shared, shared]  # Both point to same object\n</code></pre>"},{"location":"user-guide/expressions/#3-normalize-early","title":"3. Normalize Early","text":"<p>Apply normalization rules early:</p> <pre><code># Convert to standard form early\ndef normalize(expr):\n    # Apply commutativity, associativity, etc.\n    return expr\n</code></pre>"},{"location":"user-guide/expressions/#4-document-custom-operators","title":"4. Document Custom Operators","text":"<p>If you define custom operators, document them:</p> <pre><code># Custom operator: 'dot' for dot product\n# Usage: ['dot', [1, 2, 3], [4, 5, 6]]\n</code></pre>"},{"location":"user-guide/expressions/#conversion-to-other-formats","title":"Conversion to Other Formats","text":""},{"location":"user-guide/expressions/#to-string","title":"To String","text":"<pre><code>def to_infix(expr):\n    \"\"\"Convert to infix string notation.\"\"\"\n    if isinstance(expr, list):\n        op = expr[0]\n        if op in ['+', '-', '*', '/', '^']:\n            left = to_infix(expr[1])\n            right = to_infix(expr[2])\n            return f\"({left} {op} {right})\"\n        else:\n            args = ', '.join(to_infix(e) for e in expr[1:])\n            return f\"{op}({args})\"\n    else:\n        return str(expr)\n\n# Example\nexpr = ['+', ['*', 2, 'x'], 3]\nprint(to_infix(expr))  # ((2 * x) + 3)\n</code></pre>"},{"location":"user-guide/expressions/#to-latex","title":"To LaTeX","text":"<pre><code>def to_latex(expr):\n    \"\"\"Convert to LaTeX notation.\"\"\"\n    if isinstance(expr, list):\n        op = expr[0]\n        if op == '+':\n            return f\"{to_latex(expr[1])} + {to_latex(expr[2])}\"\n        elif op == '*':\n            return f\"{to_latex(expr[1])} \\\\cdot {to_latex(expr[2])}\"\n        elif op == '^':\n            return f\"{to_latex(expr[1])}^{{{to_latex(expr[2])}}}\"\n        elif op == '/':\n            return f\"\\\\frac{{{to_latex(expr[1])}}}{{{to_latex(expr[2])}}}\"\n        else:\n            args = ', '.join(to_latex(e) for e in expr[1:])\n            return f\"\\\\{op}({args})\"\n    else:\n        return str(expr)\n</code></pre>"},{"location":"user-guide/expressions/#from-other-formats","title":"From Other Formats","text":"<pre><code># From SymPy\ndef from_sympy(sympy_expr):\n    # Convert SymPy expression to XTK\n    pass\n\n# From string\ndef from_string(s):\n    # Parse string to XTK expression\n    pass\n</code></pre>"},{"location":"user-guide/expressions/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Pattern Matching on expressions</li> <li>Explore Rewrite Rules for transforming expressions</li> <li>Try Simplification techniques</li> </ul>"},{"location":"user-guide/pattern-matching/","title":"Pattern Matching","text":"<p>Pattern matching is the cornerstone of XTK's expression rewriting system. This guide covers everything you need to know about creating and using patterns effectively.</p>"},{"location":"user-guide/pattern-matching/#what-is-pattern-matching","title":"What is Pattern Matching?","text":"<p>Pattern matching determines whether an expression has a specific structure and extracts sub-expressions for use in transformations.</p>"},{"location":"user-guide/pattern-matching/#basic-idea","title":"Basic Idea","text":"<pre><code>pattern = ['+', ['?', 'x'], ['?', 'y']]\nexpression = ['+', 2, 3]\n\n# Does expression match pattern? Yes!\n# Bindings: {'x': 2, 'y': 3}\n</code></pre>"},{"location":"user-guide/pattern-matching/#pattern-variables","title":"Pattern Variables","text":"<p>XTK provides three types of pattern variables:</p>"},{"location":"user-guide/pattern-matching/#1-universal-pattern","title":"1. Universal Pattern (<code>?</code>)","text":"<p>Matches any expression:</p> <pre><code>from xtk.rewriter import match\n\npattern = ['?', 'x']\n\n# Matches constants\nmatch(pattern, 42, {})  # {'x': 42}\n\n# Matches variables\nmatch(pattern, 'a', {})  # {'x': 'a'}\n\n# Matches compound expressions\nmatch(pattern, ['+', 2, 3], {})  # {'x': ['+', 2, 3]}\n</code></pre>"},{"location":"user-guide/pattern-matching/#2-constant-pattern-c","title":"2. Constant Pattern (<code>?c</code>)","text":"<p>Matches only constants (numbers):</p> <pre><code>pattern = ['?c', 'c']\n\n# Matches\nmatch(pattern, 42, {})     # {'c': 42}\nmatch(pattern, 3.14, {})   # {'c': 3.14}\nmatch(pattern, -7, {})     # {'c': -7}\n\n# Does not match\nmatch(pattern, 'x', {})         # \"failed\"\nmatch(pattern, ['+', 2, 3], {}) # \"failed\"\n</code></pre>"},{"location":"user-guide/pattern-matching/#3-variable-pattern-v","title":"3. Variable Pattern (<code>?v</code>)","text":"<p>Matches only variables (symbols):</p> <pre><code>pattern = ['?v', 'v']\n\n# Matches\nmatch(pattern, 'x', {})    # {'v': 'x'}\nmatch(pattern, 'foo', {})  # {'v': 'foo'}\n\n# Does not match\nmatch(pattern, 42, {})          # \"failed\"\nmatch(pattern, ['+', 2, 3], {}) # \"failed\"\n</code></pre>"},{"location":"user-guide/pattern-matching/#pattern-structure","title":"Pattern Structure","text":""},{"location":"user-guide/pattern-matching/#exact-matching","title":"Exact Matching","text":"<p>Non-pattern elements must match exactly:</p> <pre><code>pattern = ['+', 'x', 0]\nexpr = ['+', 'x', 0]   # Matches\nexpr = ['+', 'x', 1]   # Does not match\nexpr = ['-', 'x', 0]   # Does not match\n</code></pre>"},{"location":"user-guide/pattern-matching/#list-structure","title":"List Structure","text":"<p>Lists must have the same structure:</p> <pre><code>pattern = ['+', ['?', 'x'], ['?', 'y']]\n\n# Matches: same structure\nexpr = ['+', 2, 3]\nexpr = ['+', 'a', 'b']\nexpr = ['+', ['+', 1, 2], 3]\n\n# Does not match: wrong operator\nexpr = ['*', 2, 3]\n\n# Does not match: wrong arity\nexpr = ['+', 2]\nexpr = ['+', 2, 3, 4]\n</code></pre>"},{"location":"user-guide/pattern-matching/#nested-patterns","title":"Nested Patterns","text":"<p>Patterns can be nested arbitrarily:</p> <pre><code># Match: (f + g) * h\npattern = ['*', ['+', ['?', 'f'], ['?', 'g']], ['?', 'h']]\n\nexpr = ['*', ['+', 'x', 'y'], 'z']\n# Bindings: {'f': 'x', 'g': 'y', 'h': 'z'}\n</code></pre>"},{"location":"user-guide/pattern-matching/#advanced-pattern-matching","title":"Advanced Pattern Matching","text":""},{"location":"user-guide/pattern-matching/#multiple-occurrences","title":"Multiple Occurrences","text":"<p>The same pattern variable can appear multiple times:</p> <pre><code># Match: x + x (same variable twice)\npattern = ['+', ['?v', 'x'], ['?v', 'x']]\n\nexpr = ['+', 'a', 'a']   # Matches: {'x': 'a'}\nexpr = ['+', 'a', 'b']   # Does not match (different vars)\n</code></pre>"},{"location":"user-guide/pattern-matching/#deeply-nested-patterns","title":"Deeply Nested Patterns","text":"<pre><code># Match: d/dx(f(g(x)))\npattern = ['dd', ['f', ['g', ['?v', 'x']]], ['?v', 'x']]\n\nexpr = ['dd', ['sin', ['cos', 'x']], 'x']\n# Bindings: {'x': 'x'}\n</code></pre>"},{"location":"user-guide/pattern-matching/#combining-pattern-types","title":"Combining Pattern Types","text":"<pre><code># Match: constant * variable\npattern = ['*', ['?c', 'c'], ['?v', 'x']]\n\nexpr = ['*', 2, 'a']      # Matches: {'c': 2, 'x': 'a'}\nexpr = ['*', 'a', 2]      # Does not match (order matters)\nexpr = ['*', 2, 3]        # Does not match (3 is not a variable)\n</code></pre>"},{"location":"user-guide/pattern-matching/#pattern-matching-examples","title":"Pattern Matching Examples","text":""},{"location":"user-guide/pattern-matching/#identity-patterns","title":"Identity Patterns","text":"<pre><code># x + 0\npattern = ['+', ['?', 'x'], 0]\n\n# x * 1\npattern = ['*', ['?', 'x'], 1]\n\n# x * 0\npattern = ['*', ['?', 'x'], 0]\n</code></pre>"},{"location":"user-guide/pattern-matching/#commutative-patterns","title":"Commutative Patterns","text":"<p>To handle commutativity, define both orders:</p> <pre><code>rules = [\n    [['*', ['?c', 'c'], ['?v', 'x']], ['*', [':', 'x'], [':', 'c']]],\n    [['*', ['?v', 'x'], ['?c', 'c']], ['*', [':', 'x'], [':', 'c']]]\n]\n</code></pre>"},{"location":"user-guide/pattern-matching/#associative-patterns","title":"Associative Patterns","text":"<pre><code># Flatten: (x + y) + z =&gt; x + (y + z)\npattern = [['+', ['+', ['?', 'x'], ['?', 'y']], ['?', 'z']]]\nskeleton = ['+', [':', 'x'], ['+', [':', 'y'], [':', 'z']]]\n</code></pre>"},{"location":"user-guide/pattern-matching/#derivative-patterns","title":"Derivative Patterns","text":"<pre><code># Constant: d(c)/dx = 0\n[['dd', ['?c', 'c'], ['?v', 'x']], 0]\n\n# Variable: d(x)/dx = 1\n[['dd', ['?v', 'x'], ['?v', 'x']], 1]\n\n# Sum rule: d(f+g)/dx = df/dx + dg/dx\n[['dd', ['+', ['?', 'f'], ['?', 'g']], ['?v', 'x']],\n ['+', ['dd', [':', 'f'], [':', 'x']], ['dd', [':', 'g'], [':', 'x']]]]\n\n# Product rule: d(fg)/dx = f'g + fg'\n[['dd', ['*', ['?', 'f'], ['?', 'g']], ['?v', 'x']],\n ['+', ['*', ['dd', [':', 'f'], [':', 'x']], [':', 'g']],\n      ['*', [':', 'f'], ['dd', [':', 'g'], [':', 'x']]]]]\n</code></pre>"},{"location":"user-guide/pattern-matching/#the-match-function","title":"The match() Function","text":""},{"location":"user-guide/pattern-matching/#function-signature","title":"Function Signature","text":"<pre><code>def match(pattern, expression, bindings):\n    \"\"\"\n    Match a pattern against an expression.\n\n    Args:\n        pattern: The pattern to match\n        expression: The expression to match against\n        bindings: Existing variable bindings\n\n    Returns:\n        Updated bindings dict if successful, \"failed\" otherwise\n    \"\"\"\n</code></pre>"},{"location":"user-guide/pattern-matching/#usage-examples","title":"Usage Examples","text":""},{"location":"user-guide/pattern-matching/#simple-match","title":"Simple Match","text":"<pre><code>from xtk.rewriter import match\n\npattern = ['+', ['?', 'x'], ['?', 'y']]\nexpr = ['+', 2, 3]\nresult = match(pattern, expr, {})\n\nprint(result)  # {'x': 2, 'y': 3}\n</code></pre>"},{"location":"user-guide/pattern-matching/#match-with-existing-bindings","title":"Match with Existing Bindings","text":"<pre><code># Start with some bindings\nbindings = {'x': 2}\n\npattern = ['+', [':', 'x'], ['?', 'y']]\nexpr = ['+', 2, 3]\n\nresult = match(pattern, expr, bindings)\nprint(result)  # {'x': 2, 'y': 3}\n</code></pre>"},{"location":"user-guide/pattern-matching/#match-failure","title":"Match Failure","text":"<pre><code>pattern = ['+', ['?', 'x'], ['?', 'y']]\nexpr = ['*', 2, 3]  # Wrong operator\n\nresult = match(pattern, expr, {})\nprint(result)  # \"failed\"\n</code></pre>"},{"location":"user-guide/pattern-matching/#pattern-matching-strategies","title":"Pattern Matching Strategies","text":""},{"location":"user-guide/pattern-matching/#specific-to-general","title":"Specific to General","text":"<p>Order patterns from most specific to most general:</p> <pre><code>rules = [\n    # Most specific: exact pattern\n    [['+', 0, 0], 0],\n\n    # More specific: one pattern variable\n    [['+', ['?', 'x'], 0], [':', 'x']],\n\n    # Less specific: two pattern variables\n    [['+', ['?', 'x'], ['?', 'y']], ['+', [':', 'y'], [':', 'x']]],\n\n    # Most general: anything\n    [['?', 'x'], ['generic', [':', 'x']]]\n]\n</code></pre>"},{"location":"user-guide/pattern-matching/#defensive-patterns","title":"Defensive Patterns","text":"<p>Use type constraints to avoid unwanted matches:</p> <pre><code># Bad: too general\npattern = ['dd', ['?', 'expr'], ['?', 'var']]\n\n# Good: constrained types\npattern = ['dd', ['?', 'expr'], ['?v', 'var']]\n# Now 'var' must be a variable, not an expression\n</code></pre>"},{"location":"user-guide/pattern-matching/#greedy-vs-conservative","title":"Greedy vs Conservative","text":"<pre><code># Greedy: matches as much as possible\npattern = ['+', ['?', 'sum']]\n# Matches any addition, binds entire tail to 'sum'\n\n# Conservative: explicit structure\npattern = ['+', ['?', 'x'], ['?', 'y']]\n# Matches binary addition only\n</code></pre>"},{"location":"user-guide/pattern-matching/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"user-guide/pattern-matching/#1-variable-shadowing","title":"1. Variable Shadowing","text":"<pre><code># Problem: 'x' used twice with different meanings\npattern = ['+', ['?', 'x'], ['?', 'x']]\nexpr = ['+', 'a', 'b']\n# Does not match! Both must be same\n\n# Solution: use different variable names\npattern = ['+', ['?', 'x'], ['?', 'y']]\n</code></pre>"},{"location":"user-guide/pattern-matching/#2-overly-general-patterns","title":"2. Overly General Patterns","text":"<pre><code># Problem: matches everything\npattern = ['?', 'x']\n\n# Solution: be more specific\npattern = ['+', ['?', 'x'], ['?', 'y']]\n</code></pre>"},{"location":"user-guide/pattern-matching/#3-order-sensitivity","title":"3. Order Sensitivity","text":"<pre><code># Only matches x + 0, not 0 + x\npattern = ['+', ['?', 'x'], 0]\n\n# Solution: add both patterns\npatterns = [\n    [['+', ['?', 'x'], 0], [':', 'x']],\n    [['+', 0, ['?', 'x']], [':', 'x']]\n]\n</code></pre>"},{"location":"user-guide/pattern-matching/#4-incomplete-type-constraints","title":"4. Incomplete Type Constraints","text":"<pre><code># Problem: might match non-numbers\npattern = ['+', ['?', 'x'], ['?', 'y']]\n\n# Solution: use type constraints if needed\npattern = ['+', ['?c', 'x'], ['?c', 'y']]\n</code></pre>"},{"location":"user-guide/pattern-matching/#testing-patterns","title":"Testing Patterns","text":""},{"location":"user-guide/pattern-matching/#interactive-testing","title":"Interactive Testing","text":"<p>Use the REPL to test patterns:</p> <pre><code>xtk&gt; /pattern ['+', ['?', 'x'], 0]\nPattern defined\n\nxtk&gt; /test ['+', 'a', 0]\nMatch: {'x': 'a'}\n\nxtk&gt; /test ['+', 'a', 1]\nFailed\n</code></pre>"},{"location":"user-guide/pattern-matching/#unit-tests","title":"Unit Tests","text":"<p>Write tests for your patterns:</p> <pre><code>import unittest\nfrom xtk.rewriter import match\n\nclass TestPatterns(unittest.TestCase):\n    def test_identity_pattern(self):\n        pattern = ['+', ['?', 'x'], 0]\n        expr = ['+', 'a', 0]\n        result = match(pattern, expr, {})\n        self.assertEqual(result, {'x': 'a'})\n\n    def test_no_match(self):\n        pattern = ['+', ['?', 'x'], 0]\n        expr = ['+', 'a', 1]\n        result = match(pattern, expr, {})\n        self.assertEqual(result, \"failed\")\n</code></pre>"},{"location":"user-guide/pattern-matching/#performance-considerations","title":"Performance Considerations","text":""},{"location":"user-guide/pattern-matching/#pattern-complexity","title":"Pattern Complexity","text":"<ul> <li>Simple patterns match faster</li> <li>Deeply nested patterns are slower</li> <li>Type constraints (<code>?c</code>, <code>?v</code>) add overhead</li> </ul>"},{"location":"user-guide/pattern-matching/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Use specific patterns first</li> <li>Minimize pattern depth</li> <li>Cache compiled patterns (if implementing custom matcher)</li> <li>Limit backtracking in complex patterns</li> </ol>"},{"location":"user-guide/pattern-matching/#pattern-libraries","title":"Pattern Libraries","text":""},{"location":"user-guide/pattern-matching/#building-reusable-patterns","title":"Building Reusable Patterns","text":"<pre><code># patterns.py\nARITHMETIC_PATTERNS = {\n    'identity_add': ['+', ['?', 'x'], 0],\n    'identity_mul': ['*', ['?', 'x'], 1],\n    'zero_mul': ['*', ['?', 'x'], 0],\n}\n\nCALCULUS_PATTERNS = {\n    'derivative_const': ['dd', ['?c', 'c'], ['?v', 'x']],\n    'derivative_var': ['dd', ['?v', 'x'], ['?v', 'x']],\n}\n</code></pre>"},{"location":"user-guide/pattern-matching/#using-pattern-libraries","title":"Using Pattern Libraries","text":"<pre><code>from patterns import ARITHMETIC_PATTERNS\n\nrules = [\n    [ARITHMETIC_PATTERNS['identity_add'], [':', 'x']],\n    [ARITHMETIC_PATTERNS['identity_mul'], [':', 'x']],\n]\n</code></pre>"},{"location":"user-guide/pattern-matching/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Rewrite Rules that use these patterns</li> <li>Explore Simplification strategies</li> <li>Try Advanced Custom Rules</li> </ul>"}]}